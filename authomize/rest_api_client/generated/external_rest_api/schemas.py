# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2023-04-19T20:36:14+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Extra, Field, constr


class AccessTypes(Enum):
    Unknown = 'Unknown'
    All = 'All'
    Owner = 'Owner'
    Login = 'Login'
    Read = 'Read'
    ReadMetadata = 'ReadMetadata'
    Write = 'Write'
    Create = 'Create'
    Delete = 'Delete'
    Execute = 'Execute'
    Enable = 'Enable'
    Assign = 'Assign'
    Restore = 'Restore'
    Import = 'Import'
    Export = 'Export'
    Get = 'Get'
    Set = 'Set'
    Update = 'Update'
    Cancel = 'Cancel'
    Use = 'Use'
    AllowUse = 'AllowUse'
    List = 'List'
    Administrative = 'Administrative'
    Delegate = 'Delegate'
    Join = 'Join'
    Invite = 'Invite'
    Leave = 'Leave'
    Share = 'Share'


class AccountsAssociationSchema(BaseModel):
    sourceId: constr(min_length=1) = Field(
        ..., description='Source account ID **Mandatory**\n', title='Sourceid'
    )
    targetId: constr(min_length=1) = Field(
        ...,
        description='Target grouping ID to associate with  **Mandatory**.\n',
        title='Targetid',
    )


class ActorType(Enum):
    Authomize = 'Authomize'
    User = 'User'


class AssetInheritanceSchema(BaseModel):
    sourceId: constr(min_length=1) = Field(
        ..., description='ID of the source asset. **Mandatory**\n', title='Sourceid'
    )
    targetId: constr(min_length=1) = Field(
        ...,
        description='The ID of the iherited asset (or assets). **Mandatory**\n',
        title='Targetid',
    )


class AssetType(Enum):
    Application = 'Application'
    Database = 'Database'
    Drive = 'Drive'
    File = 'File'
    Folder = 'Folder'
    GitRepository = 'GitRepository'
    Integration = 'Integration'
    Project = 'Project'
    Site = 'Site'
    Table = 'Table'
    Ticket = 'Ticket'
    VirtualMachine = 'VirtualMachine'
    Secret = 'Secret'
    Other = 'Other'


class AssetTypes(Enum):
    Resource = 'Resource'
    File = 'File'
    Folder = 'Folder'
    Drive = 'Drive'
    Site = 'Site'
    Application = 'Application'
    Integration = 'Integration'
    Package = 'Package'
    Project = 'Project'
    Cluster = 'Cluster'
    Dataset = 'Dataset'
    Subscription = 'Subscription'
    Table = 'Table'
    TableRecord = 'TableRecord'
    Disk = 'Disk'
    Image = 'Image'
    Instance = 'Instance'
    Snapshot = 'Snapshot'
    Service = 'Service'
    Topic = 'Topic'
    Bucket = 'Bucket'
    BillingAccount = 'BillingAccount'
    Device = 'Device'
    Calendar = 'Calendar'
    Policy = 'Policy'
    GitRepository = 'GitRepository'
    Network = 'Network'
    Vpc = 'Vpc'
    NetworkInterface = 'NetworkInterface'
    VirtualMachine = 'VirtualMachine'
    NetworkSecurityGroup = 'NetworkSecurityGroup'
    Ticket = 'Ticket'
    NetworkSubnet = 'NetworkSubnet'
    NetworkAcl = 'NetworkAcl'
    RouteTable = 'RouteTable'
    NetworkAddress = 'NetworkAddress'
    Secret = 'Secret'
    Storage = 'Storage'
    Workspace = 'Workspace'
    SharedLink = 'SharedLink'
    Collection = 'Collection'
    Database = 'Database'
    ServerlessFunction = 'ServerlessFunction'
    ServerlessApplication = 'ServerlessApplication'
    Gateway = 'Gateway'
    ImageRepository = 'ImageRepository'
    Resource_BusinessAccount = 'Resource_BusinessAccount'
    LoadBalancer = 'LoadBalancer'
    Listener = 'Listener'


class AssetsInheritance(BaseModel):
    fromId: str = Field(..., title='Fromid')
    toId: str = Field(..., title='Toid')


class AvailableConnectorId(Enum):
    restApiImport = 'restApiImport'


class BaseMergeRuleRequest(BaseModel):
    baseIdentityIds: List[str] = Field(..., min_items=2, title='Baseidentityids')
    actorId: str = Field(..., title='Actorid')
    actorType: ActorType


class ConnectorStatus(Enum):
    initializing = 'initializing'
    validating = 'validating'
    failure = 'failure'
    enabled = 'enabled'
    installable = 'installable'
    archived = 'archived'
    disabled = 'disabled'
    deleted = 'deleted'


class DistinctMergeRuleRequest(BaseModel):
    distinctIdentityIds: List[str] = Field(..., min_items=2, title='Distinctidentityids')
    actorId: str = Field(..., title='Actorid')
    actorType: ActorType


class ExportResponse(BaseModel):
    exportId: str = Field(..., title='Exportid')
    exportUrl: str = Field(..., title='Exporturl')


class GroupingType(Enum):
    Group = 'Group'
    VirtualGroup = 'VirtualGroup'


class GroupingsAssociationSchema(BaseModel):
    sourceId: constr(min_length=1) = Field(
        ..., description='Grouping source ID **Mandatory**\n', title='Sourceid'
    )
    targetId: constr(min_length=1) = Field(
        ...,
        description='Grouping Target ID  **Mandatory**. The grouping to associate with.\n',
        title='Targetid',
    )


class IdentitiesInheritance(BaseModel):
    fromId: str = Field(..., title='Fromid')
    toId: str = Field(..., title='Toid')


class IdentityTypes(Enum):
    Identity = 'Identity'
    Person = 'Person'
    User = 'User'
    Group = 'Group'
    EntitlementProxy = 'EntitlementProxy'
    AccessKey = 'AccessKey'
    ServiceAccount = 'ServiceAccount'
    Alias = 'Alias'
    Domain = 'Domain'
    Organization = 'Organization'
    TaskPerformer = 'TaskPerformer'
    BusinessAccount = 'BusinessAccount'


class NewAccountsAssociationRequestSchema(BaseModel):
    sourceId: constr(min_length=1) = Field(
        ..., description='Source account ID **Mandatory**\n', title='Sourceid'
    )
    targetId: constr(min_length=1) = Field(
        ...,
        description='Target grouping ID to associate with  **Mandatory**.\n',
        title='Targetid',
    )


class NewAccountsAssociationResponseDataSchema(BaseModel):
    validSourceIds: List[str] = Field(
        ..., description='List of **valid** source account ids.', title='Validsourceids'
    )
    validTargetIds: List[str] = Field(
        ...,
        description='List of **valid** target grouping ids.',
        title='Validtargetids',
    )
    invalidSourceIds: List[str] = Field(
        ...,
        description='List of **invalid** source account ids.',
        title='Invalidsourceids',
    )
    invalidTargetIds: List[str] = Field(
        ...,
        description='List of **invalid** target grouping ids.',
        title='Invalidtargetids',
    )


class NewAccountsAssociationResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[NewAccountsAssociationResponseDataSchema] = Field(
        {}, description='Response data.', title='Data'
    )


class NewAccountsAssociationsListRequestSchema(BaseModel):
    data: List[NewAccountsAssociationRequestSchema] = Field(
        ...,
        description='New Accounts Associations',
        max_items=10000,
        min_items=1,
        title='Data',
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class NewAssetInheritanceRequestSchema(BaseModel):
    sourceId: constr(min_length=1) = Field(
        ..., description='ID of the source asset. **Mandatory**\n', title='Sourceid'
    )
    targetId: constr(min_length=1) = Field(
        ...,
        description='The ID of the iherited asset (or assets). **Mandatory**\n',
        title='Targetid',
    )


class NewAssetRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ..., description='Asset ID. **Mandatory, must be unique.**\n', title='Uniqueid'
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The asset ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: constr(min_length=1) = Field(
        ...,
        description='The name of the asset. The default is the Asset ID. **Mandatory**\n',
        title='Name',
    )
    type: Optional[AssetType] = Field(
        'Other',
        description='The asset types that are supported by Authomize **Mandatory**\n\nPermitted values:\n\n   •\t`Application` (federation) \n   •\t`Database`\n   •\t`Drive`\n   •\t`File`\n   •\t`Folder`\n   •\t`GitRepository`\n   •\t`Integration`\n   •\t`Project`\n   •\t`Site`\n   •\t`Table`\n   •\t`Ticket`\n   •\t`VirtualMachine`\n   •\t`Other`\n\nIf the asset type does not exist use `Other`.\n',
    )
    originType: Optional[str] = Field(
        None,
        description='The asset type in the source system.\nThe default is the canonical type (if not mentioned).\n',
        title='Origintype',
    )
    createdAt: Optional[datetime] = Field(
        None,
        description='The date (in ISO 8601 format) that the asset was created.\nThe default is `null`.\n',
        title='Createdat',
    )
    lastUsedAt: Optional[datetime] = Field(
        None,
        description='The date (in ISO 8601 format) of the last time that the asset was in use.\nThe default is `null`.\n',
        title='Lastusedat',
    )
    description: Optional[str] = Field(
        None,
        description='A description of the asset (up to 512 characters).\n',
        title='Description',
    )
    href: Optional[str] = Field(
        None, description='A link to the asset in the source system.\n', title='Href'
    )
    owner: Optional[str] = Field(None, description='The owner ID', title='Owner')
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='Tags associated with the asset.\n', title='Tags'
    )


class NewAssetsInheritanceListRequestSchema(BaseModel):
    data: List[NewAssetInheritanceRequestSchema] = Field(
        ...,
        description='New Assets Inheritance',
        max_items=10000,
        min_items=1,
        title='Data',
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class NewAssetsInheritanceResponseDataSchema(BaseModel):
    validSourceIds: List[str] = Field(
        ..., description='List of **valid** source assets ids.', title='Validsourceids'
    )
    validTargetIds: List[str] = Field(
        ..., description='List of **valid** target assets ids.', title='Validtargetids'
    )
    invalidSourceIds: List[str] = Field(
        ...,
        description='List of **invalid** source assets ids.',
        title='Invalidsourceids',
    )
    invalidTargetIds: List[str] = Field(
        ...,
        description='List of **invalid** target assets ids.',
        title='Invalidtargetids',
    )


class NewAssetsInheritanceResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[NewAssetsInheritanceResponseDataSchema] = Field(
        {}, description='Response data.', title='Data'
    )


class NewAssetsListRequestSchema(BaseModel):
    data: List[NewAssetRequestSchema] = Field(
        ..., description='New Assets', max_items=10000, min_items=1, title='Data'
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class NewAssetsResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[Any] = Field({}, description='Response data.', title='Data')
    validOwnerIds: List[str] = Field(
        ..., description='List of **valid** owner (user) ids.', title='Validownerids'
    )
    invalidOwnerIds: List[str] = Field(
        ...,
        description='List of **invalid** owner (user) ids.',
        title='Invalidownerids',
    )


class NewGroupingRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description='\nGrouping ID. **Mandatory, must be unique.**\n',
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The groupping ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: constr(min_length=1) = Field(
        ...,
        description='The name of the grouping. The default is the ID field. **Mandatory**\n',
        title='Name',
    )
    originType: Optional[str] = Field(
        None,
        description='The name of the type of grouping in the source system. The default is `Group`. Example: Group/Alias/AWS Role\n',
        title='Origintype',
    )
    type: Optional[GroupingType] = Field(
        'Group',
        description='Allowed values are `Group` and `VirtualGroup`.\n\nThe default is `Group`.\n\n`VirtualGroup` are mapped to the Authomize access explorer graph and are not present in other places in the user interface nor are they counted as a group.\n',
    )
    isRole: Optional[bool] = Field(
        False,
        description='If `Role`, the grouping represents a role in the source application and the name of the role is the grouping `name`.\n\nThe default is `False`.\n',
        title='Isrole',
    )
    anyoneCanJoinOrLeave: Optional[bool] = Field(
        False,
        description="Must be either `ture` or `false`.\nWhen set to `true` users can give themselves membership in this grouping without the grouping's managers' or owners' permission. \nExamples include public groups (M365), Google Groups with specific flags, ...\nValid only when `groupingType = Group`\n",
        title='Anyonecanjoinorleave',
    )
    owner: Optional[str] = Field(None, description='The owner ID', title='Owner')
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='Tags on the access grouping.\n', title='Tags'
    )


class NewGroupingResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[Any] = Field({}, description='Response data.', title='Data')
    validOwnerIds: List[str] = Field(
        ..., description='List of **valid** owner (user) ids.', title='Validownerids'
    )
    invalidOwnerIds: List[str] = Field(
        ...,
        description='List of **invalid** owner (user) ids.',
        title='Invalidownerids',
    )


class NewGroupingsAssociationRequestSchema(BaseModel):
    sourceId: constr(min_length=1) = Field(
        ..., description='Grouping source ID **Mandatory**\n', title='Sourceid'
    )
    targetId: constr(min_length=1) = Field(
        ...,
        description='Grouping Target ID  **Mandatory**. The grouping to associate with.\n',
        title='Targetid',
    )


class NewGroupingsAssociationResponseDataSchema(BaseModel):
    validSourceIds: List[str] = Field(
        ...,
        description='List of **valid** source grouping ids.',
        title='Validsourceids',
    )
    validTargetIds: List[str] = Field(
        ...,
        description='List of **valid** target grouping ids.',
        title='Validtargetids',
    )
    invalidSourceIds: List[str] = Field(
        ...,
        description='List of **invalid** source grouping ids.',
        title='Invalidsourceids',
    )
    invalidTargetIds: List[str] = Field(
        ...,
        description='List of **invalid** target grouping ids.',
        title='Invalidtargetids',
    )


class NewGroupingsAssociationResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[NewGroupingsAssociationResponseDataSchema] = Field(
        {}, description='Response data.', title='Data'
    )


class NewGroupingsAssociationsListRequestSchema(BaseModel):
    data: List[NewGroupingsAssociationRequestSchema] = Field(
        ...,
        description='New Groupings Associations',
        max_items=10000,
        min_items=1,
        title='Data',
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class NewGroupingsListRequestSchema(BaseModel):
    data: List[NewGroupingRequestSchema] = Field(
        ..., description='New Groupings', max_items=10000, min_items=1, title='Data'
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class NewIdentityResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[Any] = Field({}, description='Response data.', title='Data')


class NewPermissionsResponseDataSchema(BaseModel):
    validUserIds: List[str] = Field(
        ..., description='List of **valid** user ids.', title='Validuserids'
    )
    validGroupingIds: List[str] = Field(
        ..., description='List of **valid** grouping ids.', title='Validgroupingids'
    )
    validAssetIds: List[str] = Field(
        ..., description='List of **valid** asset ids.', title='Validassetids'
    )
    validPrivilegeIds: List[str] = Field(
        ..., description='List of **valid** privilege ids.', title='Validprivilegeids'
    )
    invalidUserIds: List[str] = Field(
        ..., description='List of **invalid** user ids.', title='Invaliduserids'
    )
    invalidGroupingIds: List[str] = Field(
        ..., description='List of **invalid** grouping ids.', title='Invalidgroupingids'
    )
    invalidAssetIds: List[str] = Field(
        ..., description='List of **invalid** asset ids.', title='Invalidassetids'
    )
    invalidPrivilegeIds: List[str] = Field(
        ...,
        description='List of **invalid** privilege ids.',
        title='Invalidprivilegeids',
    )


class NewPermissionsResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[NewPermissionsResponseDataSchema] = Field(
        {}, description='Response data.', title='Data'
    )


class NewPrivilegeGrantsRequestSchema(BaseModel):
    sourceId: constr(min_length=1) = Field(
        ..., description='ID of the source privilege. **Mandatory**\n', title='Sourceid'
    )
    targetId: constr(min_length=1) = Field(
        ...,
        description='ID of the granted privilege. **Mandatory**\n',
        title='Targetid',
    )


class NewPrivilegeGrantsResponseDataSchema(BaseModel):
    validSourceIds: List[str] = Field(
        ...,
        description='List of **valid** source privilege ids.',
        title='Validsourceids',
    )
    validTargetIds: List[str] = Field(
        ...,
        description='List of **valid** target privilege ids.',
        title='Validtargetids',
    )
    invalidSourceIds: List[str] = Field(
        ...,
        description='List of **invalid** source privilege ids.',
        title='Invalidsourceids',
    )
    invalidTargetIds: List[str] = Field(
        ...,
        description='List of **invalid** target privilege ids.',
        title='Invalidtargetids',
    )


class NewPrivilegeGrantsResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[NewPrivilegeGrantsResponseDataSchema] = Field(
        {}, description='Response data.', title='Data'
    )


class NewPrivilegesGrantsListRequestSchema(BaseModel):
    data: List[NewPrivilegeGrantsRequestSchema] = Field(
        ...,
        description='New Privileges Grants',
        max_items=10000,
        min_items=1,
        title='Data',
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class NewPrivilegesResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[Any] = Field({}, description='Response data.', title='Data')


class NewRestApiConnectorSchema(BaseModel):
    config: Optional[Dict[str, Any]] = Field(None, title='Config')
    serviceId: constr(min_length=1) = Field(..., title='Serviceid')


class NewUserResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[Any] = Field({}, description='Response data.', title='Data')


class Pagination(BaseModel):
    limit: Optional[int] = Field(-1, title='Limit')
    skip: Optional[int] = Field(0, title='Skip')
    total: Optional[int] = Field(-1, title='Total')
    hasMore: Optional[bool] = Field(None, title='Hasmore')
    search_after: Optional[List] = Field(None, title='Search After')


class PermissionSourceType(Enum):
    User = 'User'
    Grouping = 'Grouping'


class PrivilegeGrantSchema(BaseModel):
    sourceId: constr(min_length=1) = Field(
        ..., description='ID of the source privilege. **Mandatory**\n', title='Sourceid'
    )
    targetId: constr(min_length=1) = Field(
        ...,
        description='ID of the granted privilege. **Mandatory**\n',
        title='Targetid',
    )


class PrivilegeType(Enum):
    Administrative = 'Administrative'
    Unknown = 'Unknown'
    Read = 'Read'
    ReadMetadata = 'ReadMetadata'
    Write = 'Write'
    Create = 'Create'
    Delete = 'Delete'
    Execute = 'Execute'
    Enable = 'Enable'
    Assign = 'Assign'
    Restore = 'Restore'
    Import = 'Import'
    Export = 'Export'
    Update = 'Update'
    Cancel = 'Cancel'
    Use = 'Use'
    Delegate = 'Delegate'
    Join = 'Join'
    Invite = 'Invite'
    Share = 'Share'


class RegexReplaceRule(BaseModel):
    enabled: bool = Field(..., title='Enabled')
    pattern: str = Field(..., title='Pattern')
    replacement: str = Field(..., title='Replacement')


class ReplaceRule(BaseModel):
    enabled: bool = Field(..., title='Enabled')
    fromString: str = Field(..., title='Fromstring')
    toString: str = Field(..., title='Tostring')


class RequestSubmitResponse(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')


class RestApiConnectorSchema(BaseModel):
    config: Optional[Dict[str, Any]] = Field(None, title='Config')
    serviceId: Optional[str] = Field('', title='Serviceid')
    id: str = Field(..., title='Id')
    createdAt: Optional[datetime] = Field(None, title='Createdat')
    lastSyncedAt: Optional[str] = Field(None, title='Lastsyncedat')
    lastError: Optional[str] = Field(None, title='Lasterror')
    modifiedAt: Optional[datetime] = Field(None, title='Modifiedat')
    status: Optional[ConnectorStatus] = 'disabled'
    serviceType: str = Field(..., title='Servicetype')
    availableConnectorId: Optional[AvailableConnectorId] = 'restApiImport'
    actorType: Optional[str] = Field(None, title='Actortype')
    actorId: Optional[str] = Field(None, title='Actorid')


class SearchAccountsAssociationsListResponseSchema(BaseModel):
    data: List[AccountsAssociationSchema] = Field(
        ..., description='Accounts Associations', title='Data'
    )


class SearchAssetsInheritanceListResponseSchema(BaseModel):
    data: List[AssetInheritanceSchema] = Field(..., description='Assets Inheritance', title='Data')


class SearchGroupingsAssociationsListResponseSchema(BaseModel):
    data: List[GroupingsAssociationSchema] = Field(
        ..., description='Groupings Associations', title='Data'
    )


class SearchPrivilegeGrantsListResponseSchema(BaseModel):
    data: List[PrivilegeGrantSchema] = Field(..., description='Privilege Grants', title='Data')


class ServiceDescription(BaseModel):
    name: str = Field(..., title='Name')
    icon: Optional[str] = Field(None, title='Icon')


class SettingsFamilies(Enum):
    IdentityUnification = 'IdentityUnification'


class SettingsValueType(Enum):
    identityId = 'identityId'
    identityIdList = 'identityIdList'
    DistinctIdentityId = 'DistinctIdentityId'
    DistinctIdentityIdList = 'DistinctIdentityIdList'
    str = 'str'
    strList = 'strList'
    dictList = 'dictList'
    int = 'int'
    bool = 'bool'


class SplitRuleRequest(BaseModel):
    baseIdentityId: str = Field(..., title='Baseidentityid')
    actorId: str = Field(..., title='Actorid')
    actorType: ActorType


class SubmitResponse(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )


class TransactionStateType(Enum):
    Applying = 'Applying'
    Complete = 'Complete'
    Failed = 'Failed'
    Ingest = 'Ingest'
    IngestChunk = 'IngestChunk'
    PostProcess = 'PostProcess'
    Queue = 'Queue'


class UpdateAssetRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ..., description='Asset ID. **Mandatory, must be unique.**\n', title='Uniqueid'
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The asset ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: constr(min_length=1) = Field(
        ...,
        description='The name of the asset. The default is the Asset ID. **Mandatory**\n',
        title='Name',
    )
    type: Optional[AssetType] = Field(
        'Other',
        description='The asset types that are supported by Authomize **Mandatory**\n\nPermitted values:\n\n   •\t`Application` (federation) \n   •\t`Database`\n   •\t`Drive`\n   •\t`File`\n   •\t`Folder`\n   •\t`GitRepository`\n   •\t`Integration`\n   •\t`Project`\n   •\t`Site`\n   •\t`Table`\n   •\t`Ticket`\n   •\t`VirtualMachine`\n   •\t`Other`\n\nIf the asset type does not exist use `Other`.\n',
    )
    originType: Optional[str] = Field(
        None,
        description='The asset type in the source system.\nThe default is the canonical type (if not mentioned).\n',
        title='Origintype',
    )
    createdAt: Optional[datetime] = Field(
        None,
        description='The date (in ISO 8601 format) that the asset was created.\nThe default is `null`.\n',
        title='Createdat',
    )
    lastUsedAt: Optional[datetime] = Field(
        None,
        description='The date (in ISO 8601 format) of the last time that the asset was in use.\nThe default is `null`.\n',
        title='Lastusedat',
    )
    description: Optional[str] = Field(
        None,
        description='A description of the asset (up to 512 characters).\n',
        title='Description',
    )
    href: Optional[str] = Field(
        None, description='A link to the asset in the source system.\n', title='Href'
    )
    owner: Optional[str] = Field(None, description='The owner ID', title='Owner')
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='Tags associated with the asset.\n', title='Tags'
    )


class UpdateAssetsListRequestSchema(BaseModel):
    data: List[UpdateAssetRequestSchema] = Field(
        ..., description='Update Assets', max_items=10000, min_items=1, title='Data'
    )


class UpdateGroupingsRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description='\nGrouping ID. **Mandatory, must be unique.**\n',
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The groupping ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: constr(min_length=1) = Field(
        ...,
        description='The name of the grouping. The default is the ID field. **Mandatory**\n',
        title='Name',
    )
    originType: Optional[str] = Field(
        None,
        description='The name of the type of grouping in the source system. The default is `Group`. Example: Group/Alias/AWS Role\n',
        title='Origintype',
    )
    type: Optional[GroupingType] = Field(
        'Group',
        description='Allowed values are `Group` and `VirtualGroup`.\n\nThe default is `Group`.\n\n`VirtualGroup` are mapped to the Authomize access explorer graph and are not present in other places in the user interface nor are they counted as a group.\n',
    )
    isRole: Optional[bool] = Field(
        False,
        description='If `Role`, the grouping represents a role in the source application and the name of the role is the grouping `name`.\n\nThe default is `False`.\n',
        title='Isrole',
    )
    anyoneCanJoinOrLeave: Optional[bool] = Field(
        False,
        description="Must be either `ture` or `false`.\nWhen set to `true` users can give themselves membership in this grouping without the grouping's managers' or owners' permission. \nExamples include public groups (M365), Google Groups with specific flags, ...\nValid only when `groupingType = Group`\n",
        title='Anyonecanjoinorleave',
    )
    owner: Optional[str] = Field(None, description='The owner ID', title='Owner')
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='Tags on the access grouping.\n', title='Tags'
    )


class UpdateGroupingsResponseSchema(BaseModel):
    acceptedTimestamp: Optional[datetime] = Field(
        None,
        description='**The accepted time of the request**',
        title='Acceptedtimestamp',
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )
    data: Optional[Any] = Field({}, description='Response data.', title='Data')


class UpdatePrivilegeRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description='Privilege ID.\n\nIf not defined, set as originName. **Mandatory, must be unique.**\n',
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The privilege ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    type: Optional[PrivilegeType] = Field(
        None,
        description='The "canonical" privilege types that are supported by Authomize off-the-shelf: **Mandatory**\n\nPermitted values: \n   •\t`Administrative`\n   •\t`Unknown`\n   •\t`Read`\n   •\t`ReadMetadata`\n   •\t`Write`\n   •\t`Create`\n   •\t`Delete`\n   •\t`Execute`\n   •\t`Enable`\n   •\t`Assign`\n   •\t`Restore`\n   •\t`Import`\n   •\t`Export`\n   •\t`Update`\n   •\t`Cancel`\n   •\t`Use`\n   •\t`Delegate`\n   •\t`Join`\n   •\t`Invite`\n   •\t`Share`\n\nIf the privilege type does not exist use `Unknown` or `Use`.\n',
    )
    originName: Optional[str] = Field(
        None, description='The privilege name in the source system.', title='Originname'
    )


class UpdatePrivilegesListRequestSchema(BaseModel):
    data: List[UpdatePrivilegeRequestSchema] = Field(
        ..., description='Update Privileges', max_items=10000, min_items=1, title='Data'
    )


class UserStatus(Enum):
    Staged = 'Staged'
    Enabled = 'Enabled'
    Disabled = 'Disabled'
    Suspended = 'Suspended'
    Deleted = 'Deleted'
    Unknown = 'Unknown'


class ValidationError(BaseModel):
    loc: List[str] = Field(..., title='Location')
    msg: str = Field(..., title='Message')
    type: str = Field(..., title='Error Type')


class AccessByType(Enum):
    account = 'account'
    grouping = 'grouping'


class AccessToType(Enum):
    asset = 'asset'
    grouping = 'grouping'


class AccountExpansion(Enum):
    identity = 'identity'
    sourceApp = 'sourceApp'


class Object(Enum):
    account = 'account'


class AddIncidentCommentRequestSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    content: constr(max_length=1025) = Field(
        ..., description='Content of comment.', title='Content'
    )


class AicpaTsc2017Standard(Enum):
    CC1_1 = 'CC1.1'
    CC6_3 = 'CC6.3'
    CC5_1 = 'CC5.1'
    CC5_3 = 'CC5.3'
    CC6_1 = 'CC6.1'
    CC6_2 = 'CC6.2'
    CC6_7 = 'CC6.7'
    CC6_6 = 'CC6.6'
    CC3_2 = 'CC3.2'
    CC3_3 = 'CC3.3'
    CC3_4 = 'CC3.4'


class AlertCategoryType(Enum):
    Change_Management = 'Change Management'
    Misconfiguration = 'Misconfiguration'
    Exposure = 'Exposure'
    Privileged_Access = 'Privileged Access'
    Suspicious_Behavior = 'Suspicious Behavior'
    Least_Privilege = 'Least Privilege'
    Custom = 'Custom'
    IAM_Infrastructure_Security = 'IAM Infrastructure Security'
    Detection = 'Detection'
    Stale_Access = 'Stale Access'
    Over_privileges = 'Over-privileges'
    Privilege_Escalation = 'Privilege Escalation'
    Account_Takeover = 'Account Takeover'
    Account_Impersonation__PE__LM_ = 'Account Impersonation (PE, LM)'


class AssetExpansion(Enum):
    sourceApp = 'sourceApp'


class AttackTacticType(Enum):
    Collection = 'Collection'
    Credential_Access = 'Credential Access'
    Defense_Evasion = 'Defense Evasion'
    Discovery = 'Discovery'
    Exfiltration = 'Exfiltration'
    Impact = 'Impact'
    Initial_Access = 'Initial Access'
    Lateral_Movement = 'Lateral Movement'
    Persistence = 'Persistence'
    Privilege_Escalation = 'Privilege Escalation'


class BaseBooleanFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field_eq: Optional[bool] = Field(None, alias='$eq', description='Equals To', title='$Eq')


class BaseDateFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field_gt: Optional[datetime] = Field(None, alias='$gt', description='Greater Than', title='$Gt')
    field_gte: Optional[datetime] = Field(
        None, alias='$gte', description='Greater Than Or Equals To', title='$Gte'
    )
    field_lt: Optional[datetime] = Field(None, alias='$lt', description='Less Than', title='$Lt')
    field_lte: Optional[datetime] = Field(
        None, alias='$lte', description='Less Than Or Equals To', title='$Lte'
    )


class BaseSingleValuedStringFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field_eq: Optional[str] = Field(None, alias='$eq', description='Equals To', title='$Eq')


class BaseStringFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field_eq: Optional[str] = Field(None, alias='$eq', description='Equals To', title='$Eq')
    field_ne: Optional[str] = Field(None, alias='$ne', description='Not Equals', title='$Ne')
    field_in: Optional[List[str]] = Field(None, alias='$in', description='In', title='$In')
    field_nin: Optional[List[str]] = Field(None, alias='$nin', description='Not In', title='$Nin')
    field_ends: Optional[str] = Field(None, alias='$ends', description='Ends With', title='$Ends')
    field_begins: Optional[str] = Field(
        None, alias='$begins', description='Begins With', title='$Begins'
    )


class CampaignExpansion(Enum):
    owner = 'owner'


class CampaignStatus(Enum):
    draft = 'draft'
    initializing = 'initializing'
    running = 'running'
    completed = 'completed'
    failed = 'failed'
    empty = 'empty'
    overdue = 'overdue'


class Ccm301Standard(Enum):
    AIS_04 = 'AIS-04'
    IAM_01 = 'IAM-01'
    IAM_02 = 'IAM-02'
    IAM_03 = 'IAM-03'
    IAM_04 = 'IAM-04'
    IAM_05 = 'IAM-05'
    IAM_06 = 'IAM-06'
    IAM_07 = 'IAM-07'
    IAM_08 = 'IAM-08'
    IAM_09 = 'IAM-09'
    IAM_10 = 'IAM-10'
    IAM_11 = 'IAM-11'
    IAM_12 = 'IAM-12'
    IAM_13 = 'IAM-13'
    GRM_06 = 'GRM-06'
    IVS_06 = 'IVS-06'
    IVS_08 = 'IVS-08'
    DSI_04 = 'DSI-04'


class Ccm402Standard(Enum):
    IAM_01 = 'IAM-01'
    IAM_02 = 'IAM-02'
    IAM_03 = 'IAM-03'
    IAM_04 = 'IAM-04'
    IAM_05 = 'IAM-05'
    IAM_06 = 'IAM-06'
    IAM_07 = 'IAM-07'
    IAM_08 = 'IAM-08'
    IAM_09 = 'IAM-09'
    IAM_10 = 'IAM-10'
    IAM_11 = 'IAM-11'
    IAM_12 = 'IAM-12'
    IAM_13 = 'IAM-13'
    IAM_14 = 'IAM-14'
    IAM_15 = 'IAM-15'
    IAM_16 = 'IAM-16'
    IVS_03 = 'IVS-03'
    IVS_04 = 'IVS-04'
    DSP_07 = 'DSP-07'
    DSP_08 = 'DSP-08'
    DSP_10 = 'DSP-10'
    AIS_03 = 'AIS-03'
    DSP_17 = 'DSP-17'
    DSP_01 = 'DSP-01'
    HRS_05 = 'HRS-05'


class CisV8Standard(Enum):
    field_3_1 = '3.1'
    field_3_3 = '3.3'
    field_6_8 = '6.8'
    field_5_4 = '5.4'
    field_12_7 = '12.7'
    field_6_5 = '6.5'
    field_6_2 = '6.2'
    field_5_3 = '5.3'
    field_12_2 = '12.2'
    field_6_1 = '6.1'
    field_5_1 = '5.1'
    field_4_11 = '4.11'
    field_13_4 = '13.4'
    field_13_9 = '13.9'
    field_13_10 = '13.10'


class Cisv8(BaseModel):
    values: List[CisV8Standard] = Field(..., description='Values')
    id: Optional[str] = Field('cisv8', description='UniqueID', title='Id')
    name: Optional[str] = Field('CIS v.8', description='Name', title='Name')


class CommentSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    id: str = Field(..., description='Unique ID of comment.', title='Id')
    content: constr(max_length=1025) = Field(
        ..., description='Content of comment.', title='Content'
    )


class FieldName(Enum):
    name = 'name'
    status = 'status'
    startDate = 'startDate'
    endDate = 'endDate'
    createdAt = 'createdAt'
    reviewerType = 'reviewerType'
    templateName = 'templateName'


class IdentityExpansion(Enum):
    account = 'account'


class IncidentExpansion(Enum):
    policy = 'policy'
    assignee = 'assignee'


class IncidentSeverity(Enum):
    Low = 'Low'
    Medium = 'Medium'
    High = 'High'
    Critical = 'Critical'


class IncidentStatus(Enum):
    Open = 'Open'
    InProgress = 'InProgress'
    WaitingForInput = 'WaitingForInput'
    Closed = 'Closed'


class InventoryObjects(Enum):
    identity = 'identity'
    account = 'account'
    asset = 'asset'
    privilege = 'privilege'
    other = 'other'


class IsoIec27001Standard(Enum):
    A_6_1_2 = 'A.6.1.2'
    A_8_1_1 = 'A.8.1.1'
    A_8_1_3 = 'A.8.1.3'
    A_8_3_3 = 'A.8.3.3'
    A_9_1_1 = 'A.9.1.1'
    A_9_2_1 = 'A.9.2.1'
    A_9_2_3 = 'A.9.2.3'
    A_9_2_6 = 'A.9.2.6'
    A_9_4_1 = 'A.9.4.1'
    A_9_1_2 = 'A.9.1.2'
    A_9_4_2 = 'A.9.4.2'
    A_9_2_2 = 'A.9.2.2'
    A_13_2_1 = 'A.13.2.1'
    A_9_4_3 = 'A.9.4.3'
    A_7_2_2 = 'A.7.2.2'
    A_9_4_5 = 'A.9.4.5'
    A_8_2_3 = 'A.8.2.3'
    A_7_3_1 = 'A.7.3.1'
    A_8_1_4 = 'A.8.1.4'


class NonPaginatedResponseSchemaCommentSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    data: CommentSchema = Field(..., description='Actual Data', title='Data')


class PaginationRequestSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    limit: Optional[int] = Field(None, description='Limit', title='Limit')
    nextPage: Optional[str] = Field(None, description='Starting after', title='NextPage')


class PaginationResponseSchema(BaseModel):
    limit: Optional[int] = Field(20, description='Limit', title='Limit')
    hasMore: Optional[bool] = Field(
        None, description='Has more? `true` or `false`.', title='HasMore'
    )
    nextPage: Optional[str] = Field(None, description='Starting after', title='NextPage')


class PermissionsExpansion(Enum):
    reviewer_user = 'reviewer.user'


class PolicySchema(BaseModel):
    id: str = Field(..., description='Unique id of policy.', title='Id')
    name: str = Field(..., description='Name of policy.', title='Name')
    templateId: str = Field(..., description='Template ID', title='Templateid')


class Object1(Enum):
    identity = 'identity'


class RawIdentitySchema(BaseModel):
    id: str = Field(..., description='Unique ID', title='Id')
    object: Object1 = Field(..., description='Type of entity (here `identity`)', title='Object')
    name: str = Field(..., description='Name of Identity', title='Name')
    title: Optional[str] = Field(None, description='Title', title='Title')
    department: Optional[str] = Field(None, description='Department', title='Department')
    tagIds: Optional[List[str]] = Field([], description='List of tags', title='Tagids')
    accountIds: Optional[List[str]] = Field(
        [], description='List of associated account IDs', title='Accountids'
    )
    isDeleted: bool = Field(..., description='Is Deleted', title='Isdeleted')


class ReviewStatus(Enum):
    pending = 'pending'
    completed = 'completed'
    reviewing = 'reviewing'
    notified = 'notified'
    inactive = 'inactive'


class ReviewerExpansion(Enum):
    user = 'user'


class SearchAccountsFilterBody(BaseModel):
    class Config:
        extra = Extra.forbid

    account_id: Optional[BaseStringFilter] = Field(
        None, alias='account.id', description='Filter By Account ID', title='Account.Id'
    )
    account_sourceAppId: Optional[BaseStringFilter] = Field(
        None,
        alias='account.sourceAppId',
        description='Filter By Source App ID',
        title='Account.Sourceappid',
    )


class SearchAccountsSortFields(Enum):
    name = 'name'


class SearchAssetsFilterBody(BaseModel):
    class Config:
        extra = Extra.forbid

    asset_id: Optional[BaseStringFilter] = Field(
        None, alias='asset.id', description='Filter By Asset ID', title='Asset.Id'
    )
    asset_sourceAppId: Optional[BaseStringFilter] = Field(
        None,
        alias='asset.sourceAppId',
        description='Filter By Source App',
        title='Asset.Sourceappid',
    )


class SearchAssetsSortFields(Enum):
    name = 'name'


class SearchIdentitiesSortFields(Enum):
    name = 'name'


class SearchIncidentsSortFields(Enum):
    createdAt = 'createdAt'
    updatedAt = 'updatedAt'
    severity = 'severity'
    status = 'status'
    isResolved = 'isResolved'


class Selection(Enum):
    keep = 'keep'
    revoke = 'revoke'
    null = 'null'


class SortOrder(Enum):
    ASC = 'ASC'
    DESC = 'DESC'


class SortSchemaFieldName(BaseModel):
    class Config:
        extra = Extra.forbid

    fieldName: FieldName = Field(..., description='Sort By Field Name', title='FieldName')
    order: Optional[SortOrder] = Field('ASC', description='Sort Order', title='Order')


class SortSchemaSearchAccountsSortFields(BaseModel):
    class Config:
        extra = Extra.forbid

    fieldName: SearchAccountsSortFields = Field(
        ..., description='Sort By Field Name', title='FieldName'
    )
    order: Optional[SortOrder] = Field('ASC', description='Sort Order', title='Order')


class SortSchemaSearchAssetsSortFields(BaseModel):
    class Config:
        extra = Extra.forbid

    fieldName: SearchAssetsSortFields = Field(
        ..., description='Sort By Field Name', title='FieldName'
    )
    order: Optional[SortOrder] = Field('ASC', description='Sort Order', title='Order')


class SortSchemaSearchIdentitiesSortFields(BaseModel):
    class Config:
        extra = Extra.forbid

    fieldName: SearchIdentitiesSortFields = Field(
        ..., description='Sort By Field Name', title='FieldName'
    )
    order: Optional[SortOrder] = Field('ASC', description='Sort Order', title='Order')


class SortSchemaSearchIncidentsSortFields(BaseModel):
    class Config:
        extra = Extra.forbid

    fieldName: SearchIncidentsSortFields = Field(
        ..., description='Sort By Field Name', title='FieldName'
    )
    order: Optional[SortOrder] = Field('ASC', description='Sort Order', title='Order')


class SourceAppSchema(BaseModel):
    id: str = Field(..., description='Unique ID', title='Id')
    name: str = Field(..., description='Name', title='Name')


class StringFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field_eq: Optional[str] = Field(None, alias='$eq', description='Equals To', title='$Eq')
    field_ne: Optional[str] = Field(None, alias='$ne', description='Not Equals', title='$Ne')
    field_in: Optional[List[str]] = Field(None, alias='$in', description='In', title='$In')
    field_nin: Optional[List[str]] = Field(None, alias='$nin', description='Not In', title='$Nin')
    field_ends: Optional[str] = Field(None, alias='$ends', description='Ends With', title='$Ends')
    field_begins: Optional[str] = Field(
        None, alias='$begins', description='Begins With', title='$Begins'
    )
    field_contains: Optional[str] = Field(
        None, alias='$contains', description='Text Contains', title='$Contains'
    )


class UpdateIncidentRequestSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    assigneeId: Optional[str] = Field(
        None,
        description='ID of the entity assigned to this incident.',
        title='Assigneeid',
    )
    status: Optional[IncidentStatus] = Field(
        None,
        description='The status of the incident (Open, InProgress, WaitingForInput, or Closed).',
    )
    severity: Optional[IncidentSeverity] = Field(
        None,
        description='The severity of the incident (Low, Medium, High or Critical).',
    )


class AuthomizeConnectorsRestApiAppRoutesSchemaAccountSchemaUserSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description="User's Account ID. **Mandatory, must be unique.**\n",
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The user ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: Optional[str] = Field(None, description='Username\n', title='Name')
    email: Optional[str] = Field(None, description="User's email address.", title='Email')
    firstName: Optional[str] = Field(None, description="User's first name\n", title='Firstname')
    lastName: Optional[str] = Field(None, description="The user's last name.\n", title='Lastname')
    status: Optional[UserStatus] = Field(
        None,
        description='User status must be: `Deleted`, `Disabled`, `Enabled`, `Staged`, `Suspended`, or `Unknown`.\n',
    )
    description: Optional[str] = Field(
        None, description='Additional description of the user.\n', title='Description'
    )
    isExternal: Optional[bool] = Field(
        False,
        description='Account is external to Authomize.\nMust be either `true` or `false`.\n',
        title='Isexternal',
    )
    hasMFA: Optional[bool] = Field(
        None,
        description='Has Multi-Factor Authentication enabled.\nMust be either `true` or `false`.\n',
        title='Hasmfa',
    )
    lastLoginAt: Optional[datetime] = Field(
        None,
        description='The last login date in ISO 8601 format.\n',
        title='Lastloginat',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='One or more tags on the user account.\n', title='Tags'
    )


class AuthomizeConnectorsRestApiAppRoutesSchemaAssetsSchemaAssetSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ..., description='Asset ID. **Mandatory, must be unique.**\n', title='Uniqueid'
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The asset ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: constr(min_length=1) = Field(
        ...,
        description='The name of the asset. The default is the Asset ID. **Mandatory**\n',
        title='Name',
    )
    type: Optional[AssetType] = Field(
        'Other',
        description='The asset types that are supported by Authomize **Mandatory**\n\nPermitted values:\n\n   •\t`Application` (federation) \n   •\t`Database`\n   •\t`Drive`\n   •\t`File`\n   •\t`Folder`\n   •\t`GitRepository`\n   •\t`Integration`\n   •\t`Project`\n   •\t`Site`\n   •\t`Table`\n   •\t`Ticket`\n   •\t`VirtualMachine`\n   •\t`Other`\n\nIf the asset type does not exist use `Other`.\n',
    )
    originType: Optional[str] = Field(
        None,
        description='The asset type in the source system.\nThe default is the canonical type (if not mentioned).\n',
        title='Origintype',
    )
    createdAt: Optional[datetime] = Field(
        None,
        description='The date (in ISO 8601 format) that the asset was created.\nThe default is `null`.\n',
        title='Createdat',
    )
    lastUsedAt: Optional[datetime] = Field(
        None,
        description='The date (in ISO 8601 format) of the last time that the asset was in use.\nThe default is `null`.\n',
        title='Lastusedat',
    )
    description: Optional[str] = Field(
        None,
        description='A description of the asset (up to 512 characters).\n',
        title='Description',
    )
    href: Optional[str] = Field(
        None, description='A link to the asset in the source system.\n', title='Href'
    )
    owner: Optional[str] = Field(None, description='The owner ID', title='Owner')
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='Tags associated with the asset.\n', title='Tags'
    )


class AuthomizeConnectorsRestApiAppRoutesSchemaIdentitySchemaIdentitySchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ..., description='Identity ID **Mandatory**\n', title='Uniqueid'
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The identity ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: Optional[str] = Field(None, description='Username', title='Name')
    email: Optional[str] = Field(None, description="User's work email address.\n", title='Email')
    personalEmail: Optional[str] = Field(
        None, description="User's personal email address.\n", title='Personalemail'
    )
    firstName: Optional[str] = Field(None, description="User's first name\n", title='Firstname')
    lastName: Optional[str] = Field(None, description="The user's last name.\n", title='Lastname')
    employeeNumber: Optional[str] = Field(
        None, description='Employee number', title='Employeenumber'
    )
    status: Optional[UserStatus] = Field(
        None,
        description='The user status must be one of the following: `Deleted`, `Disabled`, `Enabled`, `Staged` or `Suspended`.\n',
    )
    country: Optional[str] = Field(None, description='Country', title='Country')
    city: Optional[str] = Field(None, description='City', title='City')
    department: Optional[str] = Field(
        None,
        description="The identity's department in the organization.\n",
        title='Department',
    )
    division: Optional[str] = Field(
        None,
        description="The identity's division in their organization.\n",
        title='Division',
    )
    title: Optional[str] = Field(None, description="The user's job title.\n", title='Title')
    managerId: Optional[str] = Field(
        None, description="The manager identity's ID.\n", title='Managerid'
    )
    hireAt: Optional[datetime] = Field(
        None,
        description="The user's first day of work (in ISO 8601 format).\n",
        title='Hireat',
    )
    terminationAt: Optional[datetime] = Field(
        None,
        description="The user's last day of work (in ISO 8601 format).\n",
        title='Terminationat',
    )
    description: Optional[str] = Field(
        None,
        description='Additional description of the identity.\n',
        title='Description',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='One or more tags on the user account.\n', title='Tags'
    )


class IsAliveResponse(BaseModel):
    isAlive: bool = Field(..., description='**isAlive**', title='Isalive')


class MeResponse(BaseModel):
    version: str = Field(..., description='**version**', title='Version')
    id: str = Field(..., description='**id**', title='Id')
    tenant: str = Field(..., description='**tenant**', title='Tenant')


class Object2(Enum):
    asset = 'asset'


class AuthomizeExternalRestApiAppRoutesSchemaInventoryAssetSchema(BaseModel):
    id: str = Field(..., description='Unique ID', title='Id')
    object: Object2 = Field(..., description='Type of entity (here `asset`)', title='Object')
    name: str = Field(..., description='Name', title='Name')
    type: str = Field(..., description='Type', title='Type')
    sourceAppId: str = Field(..., description='Source App ID', title='Sourceappid')
    sourceApp: Optional[SourceAppSchema] = Field(None, description='Source App', title='Sourceapp')
    tagIds: Optional[List[str]] = Field([], description='Tag IDs', title='Tagids')
    href: Optional[str] = Field(None, description='HREF', title='Href')
    isDeleted: bool = Field(..., description='HREF', title='Isdeleted')


class Object3(Enum):
    identity = 'identity'


class AuthomizeExternalRestApiAppRoutesSchemaStatusIsAliveResponse(BaseModel):
    isAlive: bool = Field(..., description='**isAlive**', title='Isalive')


class AuthomizeExternalRestApiAppRoutesSchemaStatusMeResponse(BaseModel):
    version: Optional[str] = Field('3.1.5', description='**version**', title='Version')
    id: str = Field(..., description='**id**', title='Id')
    tenant: str = Field(..., description='**tenant**', title='Tenant')


class AuthomizeExternalRestApiAppRoutesSchemaUsersUserSchema(BaseModel):
    userId: str = Field(..., description='Unique ID', title='Userid')
    userFirstName: str = Field(..., description='First Name', title='Userfirstname')
    userLastName: str = Field(..., description='Last Name', title='Userlastname')
    userEmail: str = Field(..., description='Email', title='Useremail')


class AccessDescription(BaseModel):
    fromIdentityId: str = Field(..., title='Fromidentityid')
    toAssetId: Optional[str] = Field(None, title='Toassetid')
    accessType: AccessTypes
    accessName: Optional[str] = Field(None, title='Accessname')


class AssetDescription(BaseModel):
    id: str = Field(..., title='Id')
    name: str = Field(..., title='Name')
    type: AssetTypes
    description: Optional[str] = Field(None, title='Description')
    logoUrl: Optional[str] = Field(None, title='Logourl')
    href: Optional[str] = Field(None, title='Href')
    createdAt: Optional[datetime] = Field(None, title='Createdat')
    isAuxiliary: Optional[bool] = Field(None, title='Isauxiliary')
    service: Optional[str] = Field(None, title='Service')
    isFederated: Optional[bool] = Field(None, title='Isfederated')


class AssetSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ..., description='Asset ID. **Mandatory, must be unique.**\n', title='Uniqueid'
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The asset ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: constr(min_length=1) = Field(
        ...,
        description='The name of the asset. The default is the Asset ID. **Mandatory**\n',
        title='Name',
    )
    type: Optional[AssetType] = Field(
        'Other',
        description='The asset types that are supported by Authomize **Mandatory**\n\nPermitted values:\n\n   •\t`Application` (federation) \n   •\t`Database`\n   •\t`Drive`\n   •\t`File`\n   •\t`Folder`\n   •\t`GitRepository`\n   •\t`Integration`\n   •\t`Project`\n   •\t`Site`\n   •\t`Table`\n   •\t`Ticket`\n   •\t`VirtualMachine`\n   •\t`Other`\n\nIf the asset type does not exist use `Other`.\n',
    )
    originType: Optional[str] = Field(
        None,
        description='The asset type in the source system.\nThe default is the canonical type (if not mentioned).\n',
        title='Origintype',
    )
    createdAt: Optional[datetime] = Field(
        None,
        description='The date (in ISO 8601 format) that the asset was created.\nThe default is `null`.\n',
        title='Createdat',
    )
    lastUsedAt: Optional[datetime] = Field(
        None,
        description='The date (in ISO 8601 format) of the last time that the asset was in use.\nThe default is `null`.\n',
        title='Lastusedat',
    )
    description: Optional[str] = Field(
        None,
        description='A description of the asset (up to 512 characters).\n',
        title='Description',
    )
    href: Optional[str] = Field(
        None, description='A link to the asset in the source system.\n', title='Href'
    )
    owner: Optional[str] = Field(None, description='The owner ID', title='Owner')
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='Tags associated with the asset.\n', title='Tags'
    )


class BundleTransactionSchema(BaseModel):
    connectorId: str = Field(..., title='Connectorid')
    transactionCreatedAt: Optional[datetime] = Field(None, title='Transactioncreatedat')
    warnings: Optional[List[str]] = Field(None, title='Warnings')
    validations: Optional[Dict[str, Any]] = Field(None, title='Validations')
    id: str = Field(..., title='Id')
    state: TransactionStateType


class GroupingSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description='\nGrouping ID. **Mandatory, must be unique.**\n',
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The groupping ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: constr(min_length=1) = Field(
        ...,
        description='The name of the grouping. The default is the ID field. **Mandatory**\n',
        title='Name',
    )
    originType: Optional[str] = Field(
        None,
        description='The name of the type of grouping in the source system. The default is `Group`. Example: Group/Alias/AWS Role\n',
        title='Origintype',
    )
    type: Optional[GroupingType] = Field(
        'Group',
        description='Allowed values are `Group` and `VirtualGroup`.\n\nThe default is `Group`.\n\n`VirtualGroup` are mapped to the Authomize access explorer graph and are not present in other places in the user interface nor are they counted as a group.\n',
    )
    isRole: Optional[bool] = Field(
        False,
        description='If `Role`, the grouping represents a role in the source application and the name of the role is the grouping `name`.\n\nThe default is `False`.\n',
        title='Isrole',
    )
    anyoneCanJoinOrLeave: Optional[bool] = Field(
        False,
        description="Must be either `ture` or `false`.\nWhen set to `true` users can give themselves membership in this grouping without the grouping's managers' or owners' permission. \nExamples include public groups (M365), Google Groups with specific flags, ...\nValid only when `groupingType = Group`\n",
        title='Anyonecanjoinorleave',
    )
    owner: Optional[str] = Field(None, description='The owner ID', title='Owner')
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='Tags on the access grouping.\n', title='Tags'
    )


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(None, title='Detail')


class IdentityDescription(BaseModel):
    id: str = Field(..., title='Id')
    name: Optional[str] = Field(None, title='Name')
    type: IdentityTypes
    userType: Optional[str] = Field(None, title='Usertype')
    email: Optional[str] = Field(None, title='Email')
    manager: Optional[str] = Field(None, title='Manager')
    title: Optional[str] = Field(None, title='Title')
    department: Optional[str] = Field(None, title='Department')
    description: Optional[str] = Field(None, title='Description')
    href: Optional[str] = Field(None, title='Href')
    createdAt: Optional[datetime] = Field(None, title='Createdat')
    terminationDate: Optional[datetime] = Field(None, title='Terminationdate')
    isExternal: Optional[bool] = Field(None, title='Isexternal')
    isAuxiliary: Optional[bool] = Field(None, title='Isauxiliary')
    hasTwoFactorAuthenticationEnabled: Optional[bool] = Field(
        None, title='Hastwofactorauthenticationenabled'
    )
    firstName: Optional[str] = Field(None, title='Firstname')
    lastName: Optional[str] = Field(None, title='Lastname')
    userName: Optional[str] = Field(None, title='Username')
    status: Optional[UserStatus] = None
    service: Optional[str] = Field(None, title='Service')
    lastLoginAt: Optional[datetime] = Field(None, title='Lastloginat')
    anyoneCanJoinOrLeave: Optional[bool] = Field(None, title='Anyonecanjoinorleave')
    tags: Optional[List[str]] = Field(None, title='Tags')
    city: Optional[str] = Field(None, title='City')
    country: Optional[str] = Field(None, title='Country')
    division: Optional[str] = Field(None, title='Division')
    employeeNumber: Optional[str] = Field(None, title='Employeenumber')
    personalEmail: Optional[str] = Field(None, title='Personalemail')
    hireDate: Optional[datetime] = Field(None, title='Hiredate')


class IdentitySchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ..., description='Identity ID **Mandatory**\n', title='Uniqueid'
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The identity ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: Optional[str] = Field(None, description='Username', title='Name')
    email: Optional[str] = Field(None, description="User's work email address.\n", title='Email')
    personalEmail: Optional[str] = Field(
        None, description="User's personal email address.\n", title='Personalemail'
    )
    firstName: Optional[str] = Field(None, description="User's first name\n", title='Firstname')
    lastName: Optional[str] = Field(None, description="The user's last name.\n", title='Lastname')
    employeeNumber: Optional[str] = Field(
        None, description='Employee number', title='Employeenumber'
    )
    status: Optional[UserStatus] = Field(
        None,
        description='The user status must be one of the following: `Deleted`, `Disabled`, `Enabled`, `Staged` or `Suspended`.\n',
    )
    country: Optional[str] = Field(None, description='Country', title='Country')
    city: Optional[str] = Field(None, description='City', title='City')
    department: Optional[str] = Field(
        None,
        description="The identity's department in the organization.\n",
        title='Department',
    )
    division: Optional[str] = Field(
        None,
        description="The identity's division in their organization.\n",
        title='Division',
    )
    title: Optional[str] = Field(None, description="The user's job title.\n", title='Title')
    managerId: Optional[str] = Field(
        None, description="The manager identity's ID.\n", title='Managerid'
    )
    hireAt: Optional[datetime] = Field(
        None,
        description="The user's first day of work (in ISO 8601 format).\n",
        title='Hireat',
    )
    terminationAt: Optional[datetime] = Field(
        None,
        description="The user's last day of work (in ISO 8601 format).\n",
        title='Terminationat',
    )
    description: Optional[str] = Field(
        None,
        description='Additional description of the identity.\n',
        title='Description',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='One or more tags on the user account.\n', title='Tags'
    )


class IdentityUnificationSettingsSchema(BaseModel):
    actorId: Optional[str] = Field(None, title='Actorid')
    actorType: Optional[ActorType] = None
    mergeInternalAndExternalAccounts: Optional[bool] = Field(
        None, title='Mergeinternalandexternalaccounts'
    )
    shouldMergeIdentitiesBySameEmail: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbysameemail'
    )
    shouldMergeIdentitiesBySameFirstNameAndLastName: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbysamefirstnameandlastname'
    )
    shouldMergeIdentitiesFirstNameInitialAndLastNameToName: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesfirstnameinitialandlastnametoname'
    )
    shouldMergeIdentitiesInDifferentGitHubOrganizations: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesindifferentgithuborganizations'
    )
    shouldMergeIdentitiesByGitHubUsernameToName: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbygithubusernametoname'
    )
    shouldMergeIdentitiesBySameEmailPrefixToFirstNameAndLastName: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbysameemailprefixtofirstnameandlastname'
    )
    shouldMergeIdentitiesBySameEmailPrefixToFirstNameInitialAndLastName: Optional[bool] = Field(
        None,
        title='Shouldmergeidentitiesbysameemailprefixtofirstnameinitialandlastname',
    )
    shouldMergeIdentitiesBySameEmailPrefixToUsername: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbysameemailprefixtousername'
    )
    mergeIdentitiesBySameEmailWithSubstring: Optional[List[ReplaceRule]] = Field(
        None, title='Mergeidentitiesbysameemailwithsubstring'
    )
    mergeIdentitiesBySameEmailWithRegex: Optional[List[RegexReplaceRule]] = Field(
        None, title='Mergeidentitiesbysameemailwithregex'
    )


class InternalSettingSchema(BaseModel):
    name: str = Field(..., title='Name')
    family: SettingsFamilies
    type: SettingsValueType
    value: Optional[Union[bool, List, Dict[str, Any], str]] = Field(None, title='Value')
    id: str = Field(..., title='Id')
    createdAt: datetime = Field(..., title='Createdat')
    modifiedAt: datetime = Field(..., title='Modifiedat')


class ItemsBundleSchema(BaseModel):
    services: Optional[List[ServiceDescription]] = Field(None, title='Services')
    identities: Optional[List[IdentityDescription]] = Field(None, title='Identities')
    assets: Optional[List[AssetDescription]] = Field(None, title='Assets')
    inheritanceIdentities: Optional[List[IdentitiesInheritance]] = Field(
        None, title='Inheritanceidentities'
    )
    inheritanceAssets: Optional[List[AssetsInheritance]] = Field(None, title='Inheritanceassets')
    access: Optional[List[AccessDescription]] = Field(None, title='Access')


class NewIdentityRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ..., description='Identity ID **Mandatory**\n', title='Uniqueid'
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The identity ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: Optional[str] = Field(None, description='Username', title='Name')
    email: Optional[str] = Field(None, description="User's work email address.\n", title='Email')
    personalEmail: Optional[str] = Field(
        None, description="User's personal email address.\n", title='Personalemail'
    )
    firstName: Optional[str] = Field(None, description="User's first name\n", title='Firstname')
    lastName: Optional[str] = Field(None, description="The user's last name.\n", title='Lastname')
    employeeNumber: Optional[str] = Field(
        None, description='Employee number', title='Employeenumber'
    )
    status: Optional[UserStatus] = Field(
        None,
        description='The user status must be one of the following: `Deleted`, `Disabled`, `Enabled`, `Staged` or `Suspended`.\n',
    )
    country: Optional[str] = Field(None, description='Country', title='Country')
    city: Optional[str] = Field(None, description='City', title='City')
    department: Optional[str] = Field(
        None,
        description="The identity's department in the organization.\n",
        title='Department',
    )
    division: Optional[str] = Field(
        None,
        description="The identity's division in their organization.\n",
        title='Division',
    )
    title: Optional[str] = Field(None, description="The user's job title.\n", title='Title')
    managerId: Optional[str] = Field(
        None, description="The manager identity's ID.\n", title='Managerid'
    )
    hireAt: Optional[datetime] = Field(
        None,
        description="The user's first day of work (in ISO 8601 format).\n",
        title='Hireat',
    )
    terminationAt: Optional[datetime] = Field(
        None,
        description="The user's last day of work (in ISO 8601 format).\n",
        title='Terminationat',
    )
    description: Optional[str] = Field(
        None,
        description='Additional description of the identity.\n',
        title='Description',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='One or more tags on the user account.\n', title='Tags'
    )


class NewIdentityUnificationSettingsSchema(BaseModel):
    actorId: Optional[str] = Field(None, title='Actorid')
    actorType: Optional[ActorType] = None
    mergeInternalAndExternalAccounts: Optional[bool] = Field(
        None, title='Mergeinternalandexternalaccounts'
    )
    shouldMergeIdentitiesBySameEmail: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbysameemail'
    )
    shouldMergeIdentitiesBySameFirstNameAndLastName: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbysamefirstnameandlastname'
    )
    shouldMergeIdentitiesFirstNameInitialAndLastNameToName: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesfirstnameinitialandlastnametoname'
    )
    shouldMergeIdentitiesInDifferentGitHubOrganizations: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesindifferentgithuborganizations'
    )
    shouldMergeIdentitiesByGitHubUsernameToName: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbygithubusernametoname'
    )
    shouldMergeIdentitiesBySameEmailPrefixToFirstNameAndLastName: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbysameemailprefixtofirstnameandlastname'
    )
    shouldMergeIdentitiesBySameEmailPrefixToFirstNameInitialAndLastName: Optional[bool] = Field(
        None,
        title='Shouldmergeidentitiesbysameemailprefixtofirstnameinitialandlastname',
    )
    shouldMergeIdentitiesBySameEmailPrefixToUsername: Optional[bool] = Field(
        None, title='Shouldmergeidentitiesbysameemailprefixtousername'
    )
    mergeIdentitiesBySameEmailWithSubstring: Optional[List[ReplaceRule]] = Field(
        None, title='Mergeidentitiesbysameemailwithsubstring'
    )
    mergeIdentitiesBySameEmailWithRegex: Optional[List[RegexReplaceRule]] = Field(
        None, title='Mergeidentitiesbysameemailwithregex'
    )


class NewPermissionRequestSchema(BaseModel):
    sourceUniqueId: constr(min_length=1) = Field(
        ...,
        description="The unique ID of the permission's source. Must be either `userId` or `groupingId`. **Mandatory**.\n",
        title='Sourceuniqueid',
    )
    sourceType: PermissionSourceType = Field(
        ...,
        description="The type of the permission's source. **Mandatory**.\n\nSet `sourceType` to either:\n\n- User `uniqueId`.\n- Grouping `uniqueId`.",
    )
    privilegeId: constr(min_length=1) = Field(
        ...,
        description='The ID of the privilege, allows access to assets. **Mandatory**.\n',
        title='Privilegeid',
    )
    assetId: Optional[str] = Field(
        None,
        description='The ID of the asset.\n\nWhen `null`, this is a global permission on the entire application (not just locally).',
        title='Assetid',
    )
    isRole: Optional[bool] = Field(
        False,
        description='If `true`, the permissions represent the role in the source application.\nThe default is `false`.\n',
        title='Isrole',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='Tags on access permissions.\n', title='Tags'
    )


class NewPermissionsListRequestSchema(BaseModel):
    data: List[NewPermissionRequestSchema] = Field(
        ..., description='New Permissions', max_items=10000, min_items=1, title='Data'
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class NewPrivilegeRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description='Privilege ID.\n\nIf not defined, set as originName. **Mandatory, must be unique.**\n',
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The privilege ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    type: PrivilegeType = Field(
        ...,
        description='The "canonical" privilege types that are supported by Authomize off-the-shelf: **Mandatory**\n\nPermitted values: \n   •\t`Administrative`\n   •\t`Unknown`\n   •\t`Read`\n   •\t`ReadMetadata`\n   •\t`Write`\n   •\t`Create`\n   •\t`Delete`\n   •\t`Execute`\n   •\t`Enable`\n   •\t`Assign`\n   •\t`Restore`\n   •\t`Import`\n   •\t`Export`\n   •\t`Update`\n   •\t`Cancel`\n   •\t`Use`\n   •\t`Delegate`\n   •\t`Join`\n   •\t`Invite`\n   •\t`Share`\n\nIf the privilege type does not exist use `Unknown` or `Use`.\n',
    )
    originName: Optional[str] = Field(
        None, description='The privilege name in the source system.', title='Originname'
    )


class NewPrivilegesListRequestSchema(BaseModel):
    data: List[NewPrivilegeRequestSchema] = Field(
        ..., description='New Privileges', max_items=10000, min_items=1, title='Data'
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class NewUserRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description="User's Account ID. **Mandatory, must be unique.**\n",
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The user ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: Optional[str] = Field(None, description='Username\n', title='Name')
    email: Optional[str] = Field(None, description="User's email address.", title='Email')
    firstName: Optional[str] = Field(None, description="User's first name\n", title='Firstname')
    lastName: Optional[str] = Field(None, description="The user's last name.\n", title='Lastname')
    status: Optional[UserStatus] = Field(
        None,
        description='User status must be: `Deleted`, `Disabled`, `Enabled`, `Staged`, `Suspended`, or `Unknown`.\n',
    )
    description: Optional[str] = Field(
        None, description='Additional description of the user.\n', title='Description'
    )
    isExternal: Optional[bool] = Field(
        False,
        description='Account is external to Authomize.\nMust be either `true` or `false`.\n',
        title='Isexternal',
    )
    hasMFA: Optional[bool] = Field(
        None,
        description='Has Multi-Factor Authentication enabled.\nMust be either `true` or `false`.\n',
        title='Hasmfa',
    )
    lastLoginAt: Optional[datetime] = Field(
        None,
        description='The last login date in ISO 8601 format.\n',
        title='Lastloginat',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='One or more tags on the user account.\n', title='Tags'
    )


class NewUsersListRequestSchema(BaseModel):
    data: List[NewUserRequestSchema] = Field(
        ..., description='New Users', max_items=10000, min_items=1, title='Data'
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class PermissionSchema(BaseModel):
    sourceUniqueId: constr(min_length=1) = Field(
        ...,
        description="The unique ID of the permission's source. Must be either `userId` or `groupingId`. **Mandatory**.\n",
        title='Sourceuniqueid',
    )
    sourceType: PermissionSourceType = Field(
        ...,
        description="The type of the permission's source. **Mandatory**.\n\nSet `sourceType` to either:\n\n- User `uniqueId`.\n- Grouping `uniqueId`.",
    )
    privilegeId: constr(min_length=1) = Field(
        ...,
        description='The ID of the privilege, allows access to assets. **Mandatory**.\n',
        title='Privilegeid',
    )
    assetId: Optional[str] = Field(
        None,
        description='The ID of the asset.\n\nWhen `null`, this is a global permission on the entire application (not just locally).',
        title='Assetid',
    )
    isRole: Optional[bool] = Field(
        False,
        description='If `true`, the permissions represent the role in the source application.\nThe default is `false`.\n',
        title='Isrole',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='Tags on access permissions.\n', title='Tags'
    )


class PrivilegeSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description='Privilege ID.\n\nIf not defined, set as originName. **Mandatory, must be unique.**\n',
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The privilege ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    type: PrivilegeType = Field(
        ...,
        description='The "canonical" privilege types that are supported by Authomize off-the-shelf: **Mandatory**\n\nPermitted values: \n   •\t`Administrative`\n   •\t`Unknown`\n   •\t`Read`\n   •\t`ReadMetadata`\n   •\t`Write`\n   •\t`Create`\n   •\t`Delete`\n   •\t`Execute`\n   •\t`Enable`\n   •\t`Assign`\n   •\t`Restore`\n   •\t`Import`\n   •\t`Export`\n   •\t`Update`\n   •\t`Cancel`\n   •\t`Use`\n   •\t`Delegate`\n   •\t`Join`\n   •\t`Invite`\n   •\t`Share`\n\nIf the privilege type does not exist use `Unknown` or `Use`.\n',
    )
    originName: Optional[str] = Field(
        None, description='The privilege name in the source system.', title='Originname'
    )


class RequestsBundleSchema(BaseModel):
    delete_app_data: Optional[bool] = Field(
        False,
        description='The Delete Application Data API is used to delete app data by `{appId}`.',
        title='Delete App Data',
    )
    createdAt: Optional[datetime] = Field(None, title='Createdat')
    new_users: Optional[List[NewUserRequestSchema]] = Field(
        None,
        description='The Create Users APIs sets up App users(by App ID).',
        title='New Users',
    )
    new_groupings: Optional[List[NewGroupingRequestSchema]] = Field(
        None,
        description='The Create Groupings API is used to create groups that have access to a particular app.',
        title='New Groupings',
    )
    new_permissions: Optional[List[NewPermissionRequestSchema]] = Field(
        None,
        description='The Create Permissions API is used to create a set of privileges, assigned to a specific target.\nA permission (also referred to as an “entitlement”) is a set of privileges, assigned to a specific target. \nExamples include: file permissions, file shares, GCP entitlements, the actual policies assigning access to roles in AWS, and inline policies.',
        title='New Permissions',
    )
    new_privileges: Optional[List[NewPrivilegeRequestSchema]] = Field(
        None,
        description='The Create Privileges API is used to define privileges that can be associated with assets.\nFor example, Read privileges on a file.\nHere you can define the type of privileges and associate it to assets in the Permission API.\n',
        title='New Privileges',
    )
    new_privileges_grants: Optional[List[NewPrivilegeGrantsRequestSchema]] = Field(
        None,
        description='The Create Privileges Grants API enables you to establish inheritance between privileges, so that a single privilege contains a set of other privileges. \nFor example, an Administrative privilege that contains read and write privileges.',
        title='New Privileges Grants',
    )
    new_accounts_association: Optional[List[NewAccountsAssociationRequestSchema]] = Field(
        None,
        description='The Create Accounts Association API creates account associations between user accounts and groups.',
        title='New Accounts Association',
    )
    new_groupings_association: Optional[List[NewGroupingsAssociationRequestSchema]] = Field(
        None,
        description='The Create Groupings Association API creates associations between groups and other groups.\n',
        title='New Groupings Association',
    )
    new_assets: Optional[List[NewAssetRequestSchema]] = Field(
        None,
        description='The Create Assets API creates assets (including asset data).',
        title='New Assets',
    )
    new_assets_inheritance: Optional[List[NewAssetInheritanceRequestSchema]] = Field(
        None,
        description='The Create Assets Inheritence API enables you to create a connection between different assets (for example, a folder that contains multiple files).\n',
        title='New Assets Inheritance',
    )
    new_identities: Optional[List[NewIdentityRequestSchema]] = Field(
        None,
        description='The Create Identities API is used to create identities. \nThe data of the identity from this API is considered "the source of truth" and overrides the identity data from other systems.\n',
        title='New Identities',
    )


class RestApiConnectorListSchema(BaseModel):
    pagination: Pagination
    data: List[RestApiConnectorSchema] = Field(..., title='Data')


class SearchAssetsListResponseSchema(BaseModel):
    data: List[AuthomizeConnectorsRestApiAppRoutesSchemaAssetsSchemaAssetSchema] = Field(
        ..., description='Assets', title='Data'
    )


class SearchGroupingResponseSchema(BaseModel):
    data: List[GroupingSchema] = Field(..., description='Groupings', title='Data')


class SearchIdentitiesListResponseSchema(BaseModel):
    data: List[AuthomizeConnectorsRestApiAppRoutesSchemaIdentitySchemaIdentitySchema] = Field(
        ..., description='Identities', title='Data'
    )


class SearchPermissionResponseSchema(BaseModel):
    data: List[PermissionSchema] = Field(..., description='Permissions', title='Data')


class SearchPrivilegesListResponseSchema(BaseModel):
    data: List[PrivilegeSchema] = Field(..., description='Privileges', title='Data')


class SearchUsersListResponseSchema(BaseModel):
    data: List[AuthomizeConnectorsRestApiAppRoutesSchemaAccountSchemaUserSchema] = Field(
        ..., description='Users', title='Data'
    )


class TransactionPaginatedSearchSchema(BaseModel):
    data: List[BundleTransactionSchema] = Field(..., title='Data')
    pagination: Pagination


class UpdateGroupingsListRequestSchema(BaseModel):
    data: List[UpdateGroupingsRequestSchema] = Field(
        ...,
        description='List of update user requests.\n',
        max_items=10000,
        min_items=1,
        title='Data',
    )


class UpdateIdentityRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ..., description='Identity ID **Mandatory**\n', title='Uniqueid'
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The identity ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: Optional[str] = Field(None, description='Username', title='Name')
    email: Optional[str] = Field(None, description="User's work email address.\n", title='Email')
    personalEmail: Optional[str] = Field(
        None, description="User's personal email address.\n", title='Personalemail'
    )
    firstName: Optional[str] = Field(None, description="User's first name\n", title='Firstname')
    lastName: Optional[str] = Field(None, description="The user's last name.\n", title='Lastname')
    employeeNumber: Optional[str] = Field(
        None, description='Employee number', title='Employeenumber'
    )
    status: Optional[UserStatus] = Field(
        None,
        description='The user status must be one of the following: `Deleted`, `Disabled`, `Enabled`, `Staged` or `Suspended`.\n',
    )
    country: Optional[str] = Field(None, description='Country', title='Country')
    city: Optional[str] = Field(None, description='City', title='City')
    department: Optional[str] = Field(
        None,
        description="The identity's department in the organization.\n",
        title='Department',
    )
    division: Optional[str] = Field(
        None,
        description="The identity's division in their organization.\n",
        title='Division',
    )
    title: Optional[str] = Field(None, description="The user's job title.\n", title='Title')
    managerId: Optional[str] = Field(
        None, description="The manager identity's ID.\n", title='Managerid'
    )
    hireAt: Optional[datetime] = Field(
        None,
        description="The user's first day of work (in ISO 8601 format).\n",
        title='Hireat',
    )
    terminationAt: Optional[datetime] = Field(
        None,
        description="The user's last day of work (in ISO 8601 format).\n",
        title='Terminationat',
    )
    description: Optional[str] = Field(
        None,
        description='Additional description of the identity.\n',
        title='Description',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='One or more tags on the user account.\n', title='Tags'
    )


class UpdateUserRequestSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description="User's Account ID. **Mandatory, must be unique.**\n",
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The user ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: Optional[str] = Field(None, description='Username\n', title='Name')
    email: Optional[str] = Field(None, description="User's email address.", title='Email')
    firstName: Optional[str] = Field(None, description="User's first name\n", title='Firstname')
    lastName: Optional[str] = Field(None, description="The user's last name.\n", title='Lastname')
    status: Optional[UserStatus] = Field(
        None,
        description='User status must be: `Deleted`, `Disabled`, `Enabled`, `Staged`, `Suspended`, or `Unknown`.\n',
    )
    description: Optional[str] = Field(
        None, description='Additional description of the user.\n', title='Description'
    )
    isExternal: Optional[bool] = Field(
        False,
        description='Account is external to Authomize.\nMust be either `true` or `false`.\n',
        title='Isexternal',
    )
    hasMFA: Optional[bool] = Field(
        None,
        description='Has Multi-Factor Authentication enabled.\nMust be either `true` or `false`.\n',
        title='Hasmfa',
    )
    lastLoginAt: Optional[datetime] = Field(
        None,
        description='The last login date in ISO 8601 format.\n',
        title='Lastloginat',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='One or more tags on the user account.\n', title='Tags'
    )


class UserSchema(BaseModel):
    uniqueId: constr(min_length=1) = Field(
        ...,
        description="User's Account ID. **Mandatory, must be unique.**\n",
        title='Uniqueid',
    )
    originId: Optional[constr(min_length=1)] = Field(
        None,
        description="The user ID in the source system.\nAs opposed to `uniqueId`, it's not mandatory and can be non-unique\n",
        title='Originid',
    )
    name: Optional[str] = Field(None, description='Username\n', title='Name')
    email: Optional[str] = Field(None, description="User's email address.", title='Email')
    firstName: Optional[str] = Field(None, description="User's first name\n", title='Firstname')
    lastName: Optional[str] = Field(None, description="The user's last name.\n", title='Lastname')
    status: Optional[UserStatus] = Field(
        None,
        description='User status must be: `Deleted`, `Disabled`, `Enabled`, `Staged`, `Suspended`, or `Unknown`.\n',
    )
    description: Optional[str] = Field(
        None, description='Additional description of the user.\n', title='Description'
    )
    isExternal: Optional[bool] = Field(
        False,
        description='Account is external to Authomize.\nMust be either `true` or `false`.\n',
        title='Isexternal',
    )
    hasMFA: Optional[bool] = Field(
        None,
        description='Has Multi-Factor Authentication enabled.\nMust be either `true` or `false`.\n',
        title='Hasmfa',
    )
    lastLoginAt: Optional[datetime] = Field(
        None,
        description='The last login date in ISO 8601 format.\n',
        title='Lastloginat',
    )
    tags: Optional[List[constr(min_length=1)]] = Field(
        None, description='One or more tags on the user account.\n', title='Tags'
    )


class AccountSchema(BaseModel):
    id: str = Field(..., description='Unique ID', title='Id')
    object: Object = Field(..., description='type of object (here `account`)', title='Object')
    name: str = Field(..., description='Name', title='Name')
    type: str = Field(..., description='Type', title='Type')
    isExternal: bool = Field(..., description='Is External', title='Isexternal')
    email: Optional[str] = Field(None, description='Email', title='Email')
    tagIds: Optional[List[str]] = Field([], description='Tag IDs', title='Tagids')
    identityId: Optional[str] = Field(
        None, description='Associated Identity ID ', title='Identityid'
    )
    identity: Optional[RawIdentitySchema] = Field(
        None, description='Associated Identity', title='Identity'
    )
    sourceAppId: Optional[str] = Field(None, description='Source App ID', title='Sourceappid')
    sourceApp: Optional[SourceAppSchema] = Field(None, description='Source App', title='Sourceapp')
    isAdmin: Optional[bool] = Field(None, description='Is Admin', title='Isadmin')
    isDeleted: bool = Field(..., description='Is Deleted', title='Isdeleted')


class AicpaTsc2017(BaseModel):
    values: List[AicpaTsc2017Standard] = Field(..., description='Values')
    id: Optional[str] = Field('aicpaTsc2017', description='UniqueID', title='Id')
    name: Optional[str] = Field('SOC 2 (TSC 2017)', description='Name', title='Name')


class BasicEnumFilterCampaignStatus(BaseModel):
    class Config:
        extra = Extra.forbid

    field_in: Optional[List[CampaignStatus]] = Field(None, alias='$in', description='In')


class BasicEnumFilterIncidentSeverity(BaseModel):
    class Config:
        extra = Extra.forbid

    field_in: Optional[List[IncidentSeverity]] = Field(None, alias='$in', description='In')


class BasicEnumFilterIncidentStatus(BaseModel):
    class Config:
        extra = Extra.forbid

    field_in: Optional[List[IncidentStatus]] = Field(None, alias='$in', description='In')


class BasicEnumFilterSelection(BaseModel):
    class Config:
        extra = Extra.forbid

    field_in: Optional[List[Selection]] = Field(None, alias='$in', description='In')


class CampaignPermissionsSearchFilterBody(BaseModel):
    class Config:
        extra = Extra.forbid

    decision: Optional[BasicEnumFilterSelection] = Field(
        None,
        description='Reviewer decisions (keep, revoke or null).\n',
        title='Decision',
    )


class CampaignSchema(BaseModel):
    id: str = Field(..., description='Unique ID of campaign', title='Id')
    name: str = Field(..., description='Name of the campaign', title='Name')
    status: CampaignStatus = Field(..., description='The campaign status')
    startDate: datetime = Field(..., description='Date when the campaign starts', title='Startdate')
    endDate: datetime = Field(..., description='Date when campaign ends', title='Enddate')
    createdAt: datetime = Field(..., description='Time of creation of campaign', title='Createdat')
    ownerUserId: str = Field(..., description='User ID of the campaign owner', title='Owneruserid')
    owner: Optional[AuthomizeExternalRestApiAppRoutesSchemaUsersUserSchema] = Field(
        None, description='User Schema of the campaign owner', title='Owner'
    )


class CampaignSearchFilterBody(BaseModel):
    class Config:
        extra = Extra.forbid

    status: Optional[BasicEnumFilterCampaignStatus] = Field(
        None,
        description='Enum: "draft" "initializing" "running" "completed" "failed" "empty" "overdue"\n',
        title='Status',
    )


class Ccm301(BaseModel):
    values: List[Ccm301Standard] = Field(..., description='Values')
    id: Optional[str] = Field('ccm301', description='UniqueID', title='Id')
    name: Optional[str] = Field('CSA STAR (CCM 3.0.1)', description='Name', title='Name')


class Ccm402(BaseModel):
    values: List[Ccm402Standard] = Field(..., description='Values')
    id: Optional[str] = Field('ccm402', description='UniqueID', title='Id')
    name: Optional[str] = Field('CSA STAR (CCM 4.0.2)', description='Name', title='Name')


class IncidentEntitiesSchema(BaseModel):
    id: str = Field(..., description='Unique id of entity.', title='Id')
    name: Optional[str] = Field(None, description='Name of entity.', title='Name')
    object: Union[InventoryObjects, str] = Field(
        ..., description='Identity | Account | Asset', title='Object'
    )
    email: Optional[str] = Field(None, description='Email', title='Email')
    originId: Optional[str] = Field(None, description='Origin ID', title='Originid')
    originType: Optional[str] = Field(None, description='Origin Type', title='Origintype')


class IsoIec27001(BaseModel):
    values: List[IsoIec27001Standard] = Field(..., description='Values')
    id: Optional[str] = Field('isoIec27001', description='UniqueID', title='Id')
    name: Optional[str] = Field('ISO/IEC 27001', description='Name', title='Name')


class NonPaginatedResponseSchemaCampaignSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    data: CampaignSchema = Field(..., description='Actual Data', title='Data')


class PaginatedResponseSchemaAccountSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    pagination: Optional[PaginationResponseSchema] = Field(
        None, description='Pagination Metadata', title='Pagination'
    )
    data: List[AccountSchema] = Field(..., description='List of Actual Data', title='Data')


class PaginatedResponseSchemaAssetSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    pagination: Optional[PaginationResponseSchema] = Field(
        None, description='Pagination Metadata', title='Pagination'
    )
    data: List[AuthomizeExternalRestApiAppRoutesSchemaInventoryAssetSchema] = Field(
        ..., description='List of Actual Data', title='Data'
    )


class PaginatedResponseSchemaCampaignSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    pagination: Optional[PaginationResponseSchema] = Field(
        None, description='Pagination Metadata', title='Pagination'
    )
    data: List[CampaignSchema] = Field(..., description='List of Actual Data', title='Data')


class ReviewerSchema(BaseModel):
    userId: str = Field(..., description='User ID of the Reviewer', title='Userid')
    campaignId: str = Field(..., description='Campaign ID', title='Campaignid')
    lastNotifiedAt: datetime = Field(
        ..., description='Time of last notified', title='Lastnotifiedat'
    )
    lastActiveAt: datetime = Field(..., description='Time of last activity', title='Lastactiveat')
    reviewStatus: Union[ReviewStatus, str] = Field(
        ..., description='Review Status', title='Reviewstatus'
    )
    id: str = Field(..., description='Unique ID', title='Id')
    user: Optional[AuthomizeExternalRestApiAppRoutesSchemaUsersUserSchema] = Field(
        None, description='User Schema of the reviewer', title='User'
    )


class SearchAccountsRequestSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    sort: Optional[List[SortSchemaSearchAccountsSortFields]] = Field(
        None, description='Sort', title='Sort'
    )
    pagination: Optional[PaginationRequestSchema] = Field(
        None, description='Pagination', title='Pagination'
    )
    expand: Optional[List[AccountExpansion]] = Field(None, description='Expand Fields')
    filter: Optional[SearchAccountsFilterBody] = Field(
        None, description='Search Accounts Filter', title='Filter'
    )


class SearchAssetsRequestSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    sort: Optional[List[SortSchemaSearchAssetsSortFields]] = Field(
        None, description='Sort', title='Sort'
    )
    pagination: Optional[PaginationRequestSchema] = Field(
        None, description='Pagination', title='Pagination'
    )
    expand: Optional[List[AssetExpansion]] = Field(None, description='Expand Fields')
    filter: Optional[SearchAssetsFilterBody] = Field(
        None, description='Search Assets Filter', title='Filter'
    )


class SearchCampaignPermissionsRequestSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    pagination: Optional[PaginationRequestSchema] = Field(
        None, description='Pagination', title='Pagination'
    )
    filter: Optional[CampaignPermissionsSearchFilterBody] = Field(
        None, description='Filter by the reviewer decisions. \n', title='Filter'
    )
    expand: Optional[List[PermissionsExpansion]] = Field(None, description='Fields to expand.\n')


class SearchCampaignsRequestSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    filter: Optional[CampaignSearchFilterBody] = Field(
        None, description='Status filter', title='Filter'
    )
    expand: Optional[List[CampaignExpansion]] = Field(None, description='Expand Fields')
    pagination: Optional[PaginationRequestSchema] = Field(
        None, description='Pagination', title='Pagination'
    )
    sort: Optional[List[SortSchemaFieldName]] = Field(None, description='Sort', title='Sort')


class SearchIdentitiesFilterBody(BaseModel):
    class Config:
        extra = Extra.forbid

    account_email: Optional[StringFilter] = Field(
        None,
        alias='account.email',
        description='Email associated with Account',
        title='Account.Email',
    )
    identity_sourceApps: Optional[BaseStringFilter] = Field(
        None,
        alias='identity.sourceApps',
        description='Source App of the Identity',
        title='Identity.Sourceapps',
    )
    identity_id: Optional[BaseStringFilter] = Field(
        None,
        alias='identity.id',
        description='Filter By Unique ID',
        title='Identity.Id',
    )


class SearchIdentitiesRequestSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    sort: Optional[List[SortSchemaSearchIdentitiesSortFields]] = Field(
        None, description='Sort', title='Sort'
    )
    pagination: Optional[PaginationRequestSchema] = Field(
        None, description='Pagination', title='Pagination'
    )
    expand: Optional[List[IdentityExpansion]] = Field(None, description='Expand Fields')
    filter: Optional[SearchIdentitiesFilterBody] = Field(
        None, description='Search Identities Filter', title='Filter'
    )


class SearchIncidentsFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    createdAt: Optional[BaseDateFilter] = Field(
        None, description='Created At date', title='Createdat'
    )
    updatedAt: Optional[BaseDateFilter] = Field(
        None, description='Updated At date', title='Updatedat'
    )
    severity: Optional[BasicEnumFilterIncidentSeverity] = Field(
        None, description='Severity', title='Severity'
    )
    status: Optional[BasicEnumFilterIncidentStatus] = Field(
        None, description='Status', title='Status'
    )
    policyId: Optional[BaseSingleValuedStringFilter] = Field(
        None, description='Policy Id ', title='Policyid'
    )
    policyTemplateId: Optional[BaseSingleValuedStringFilter] = Field(
        None, description='Policy Template ID', title='Policytemplateid'
    )
    isResolved: Optional[BaseBooleanFilter] = Field(
        None, description='Is resolved?', title='Isresolved'
    )


class SearchIncidentsRequestSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    filter: Optional[SearchIncidentsFilter] = Field(None, description='Filter', title='Filter')
    expand: Optional[List[IncidentExpansion]] = Field(None, description='Expend')
    sort: Optional[List[SortSchemaSearchIncidentsSortFields]] = Field(
        None, description='Sort', title='Sort'
    )
    pagination: Optional[PaginationRequestSchema] = Field(
        None, description='Pagination', title='Pagination'
    )


class AuthomizeExternalRestApiAppRoutesSchemaInventoryIdentitySchema(BaseModel):
    id: str = Field(..., description='Unique ID', title='Id')
    object: Object3 = Field(..., description='Type of entity (here `identity`)', title='Object')
    name: str = Field(..., description='Name of Identity', title='Name')
    title: Optional[str] = Field(None, description='Title', title='Title')
    department: Optional[str] = Field(None, description='Department', title='Department')
    tagIds: Optional[List[str]] = Field([], description='List of tags', title='Tagids')
    accountIds: Optional[List[str]] = Field(
        [], description='List of associated account IDs', title='Accountids'
    )
    isDeleted: bool = Field(..., description='Is Deleted', title='Isdeleted')
    accounts: Optional[List[AccountSchema]] = Field(
        [], description='List of associated accounts', title='Accounts'
    )


class IngestionDataBundleSchema(BaseModel):
    new_users: Optional[List[NewUserRequestSchema]] = Field(
        None,
        description='The Create Users APIs sets up App users(by App ID).',
        title='New Users',
    )
    new_groupings: Optional[List[NewGroupingRequestSchema]] = Field(
        None,
        description='The Create Groupings API is used to create groups that have access to a particular app.',
        title='New Groupings',
    )
    new_permissions: Optional[List[NewPermissionRequestSchema]] = Field(
        None,
        description='The Create Permissions API is used to create a set of privileges, assigned to a specific target.\nA permission (also referred to as an “entitlement”) is a set of privileges, assigned to a specific target. \nExamples include: file permissions, file shares, GCP entitlements, the actual policies assigning access to roles in AWS, and inline policies.',
        title='New Permissions',
    )
    new_privileges: Optional[List[NewPrivilegeRequestSchema]] = Field(
        None,
        description='The Create Privileges API is used to define privileges that can be associated with assets.\nFor example, Read privileges on a file.\nHere you can define the type of privileges and associate it to assets in the Permission API.\n',
        title='New Privileges',
    )
    new_privileges_grants: Optional[List[NewPrivilegeGrantsRequestSchema]] = Field(
        None,
        description='The Create Privileges Grants API enables you to establish inheritance between privileges, so that a single privilege contains a set of other privileges. \nFor example, an Administrative privilege that contains read and write privileges.',
        title='New Privileges Grants',
    )
    new_accounts_association: Optional[List[NewAccountsAssociationRequestSchema]] = Field(
        None,
        description='The Create Accounts Association API creates account associations between user accounts and groups.',
        title='New Accounts Association',
    )
    new_groupings_association: Optional[List[NewGroupingsAssociationRequestSchema]] = Field(
        None,
        description='The Create Groupings Association API creates associations between groups and other groups.\n',
        title='New Groupings Association',
    )
    new_assets: Optional[List[NewAssetRequestSchema]] = Field(
        None,
        description='The Create Assets API creates assets (including asset data).',
        title='New Assets',
    )
    new_assets_inheritance: Optional[List[NewAssetInheritanceRequestSchema]] = Field(
        None,
        description='The Create Assets Inheritence API enables you to create a connection between different assets (for example, a folder that contains multiple files).\n',
        title='New Assets Inheritance',
    )
    new_identities: Optional[List[NewIdentityRequestSchema]] = Field(
        None,
        description='The Create Identities API is used to create identities. \nThe data of the identity from this API is considered "the source of truth" and overrides the identity data from other systems.\n',
        title='New Identities',
    )


class InternalSettingListSchema(BaseModel):
    pagination: Optional[Pagination] = Field(
        default_factory=lambda: Pagination.parse_obj({'limit': -1, 'skip': 0, 'total': -1}),
        title='Pagination',
    )
    data: List[InternalSettingSchema] = Field(..., title='Data')


class NewIdentitiesListRequestSchema(BaseModel):
    data: List[NewIdentityRequestSchema] = Field(
        ..., description='New Identities', max_items=10000, min_items=1, title='Data'
    )
    validateOnly: Optional[bool] = Field(
        False,
        description='Validate the request without uploading the data into the system.',
        title='Validateonly',
    )


class UpdateIdentitiesListRequestSchema(BaseModel):
    data: List[UpdateIdentityRequestSchema] = Field(
        ...,
        description='List of update identity requests.\n',
        max_items=10000,
        min_items=1,
        title='Data',
    )


class UpdateUserListRequestSchema(BaseModel):
    data: List[UpdateUserRequestSchema] = Field(
        ...,
        description='List of update user requests.\n',
        max_items=10000,
        min_items=1,
        title='Data',
    )


class CampaignsPermissionSchema(BaseModel):
    id: str = Field(..., description='Campaign ID (unique). \n', title='Id')
    campaignId: str = Field(..., description='ID of the Campaign.\n', title='Campaignid')
    reviewerId: str = Field(..., description='Reviewer ID', title='Reviewerid')
    reviewer: Optional[ReviewerSchema] = Field(
        None, description='Details of the reviewer.\n', title='Reviewer'
    )
    accessById: str = Field(
        ...,
        description='Access by ID (Account or Grouping ID) that their access was reviewed. \n',
        title='Accessbyid',
    )
    accessByType: AccessByType = Field(
        ...,
        description='Type of entity that was reviewed, can be Account or Grouping.\n',
    )
    accessToId: str = Field(
        ...,
        description='Access to ID (Asset or Grouping ID) that the access to was reviewed, for example a database the access to was reviewed.  \n',
        title='Accesstoid',
    )
    accessToType: AccessToType = Field(
        ..., description='Assets or grouping that the access to was reviewed.  \n'
    )
    privilegeId: Optional[str] = Field(
        None,
        description='ID of the privileges that was reviewed. \n',
        title='Privilegeid',
    )
    decision: Optional[Selection] = Field(
        None, description='Reviewer decisions (keep, revoke or null).\n'
    )
    decisionReason: Optional[str] = Field(
        None,
        description='Reviewer decision for keeping or revoking the reviewed access.  \n',
        title='Decisionreason',
    )


class IncidentSchema(BaseModel):
    id: str = Field(..., description='Unique id', title='Id')
    createdAt: Optional[datetime] = Field(
        None, description='The date the incident was first reported.', title='Createdat'
    )
    updatedAt: Optional[datetime] = Field(
        None, description='The date the incident was last updated.', title='Updatedat'
    )
    entities: Optional[List[IncidentEntitiesSchema]] = Field(
        [], description='Entity', title='Entities'
    )
    apps: Optional[List[SourceAppSchema]] = Field([], description='Applications', title='Apps')
    category: Optional[AlertCategoryType] = Field(None, description='Category')
    tactics: Optional[List[AttackTacticType]] = Field([], description='Tactics')
    compliance: Optional[List[Union[IsoIec27001, AicpaTsc2017, Ccm402, Ccm301, Cisv8]]] = Field(
        [], description='Compliance', title='Compliance'
    )
    techniques: Optional[List[str]] = Field([], description='Techniques', title='Techniques')
    status: Optional[IncidentStatus] = Field(
        None,
        description='The status of the incident (Open, In Progress, Waiting for Input, or Closed)',
    )
    severity: IncidentSeverity = Field(
        ..., description='The severity of the incident (Low, Medium, High or Critical).'
    )
    policyId: str = Field(..., description='Unique id of policy.', title='Policyid')
    policy: Optional[PolicySchema] = Field(None, description='Policy', title='Policy')
    assigneeId: Optional[str] = Field(
        None, description='Unique id of assignee.', title='Assigneeid'
    )
    assignee: Optional[AuthomizeExternalRestApiAppRoutesSchemaUsersUserSchema] = Field(
        None, description='Assignee', title='Assignee'
    )
    recommendation: Optional[str] = Field(
        None, description='Recommendation', title='Recommendation'
    )
    description: Optional[str] = Field(None, description='Description', title='Description')
    isResolved: bool = Field(..., description='Is Resolved?', title='Isresolved')
    url: str = Field(..., description='URL', title='Url')


class NonPaginatedResponseSchemaIncidentSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    data: IncidentSchema = Field(..., description='Actual Data', title='Data')


class NonPaginatedResponseSchemaReviewerSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    data: ReviewerSchema = Field(..., description='Actual Data', title='Data')


class PaginatedResponseSchemaCampaignsPermissionSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    pagination: Optional[PaginationResponseSchema] = Field(
        None, description='Pagination Metadata', title='Pagination'
    )
    data: List[CampaignsPermissionSchema] = Field(
        ..., description='List of Actual Data', title='Data'
    )


class PaginatedResponseSchemaIdentitySchema(BaseModel):
    class Config:
        extra = Extra.forbid

    pagination: Optional[PaginationResponseSchema] = Field(
        None, description='Pagination Metadata', title='Pagination'
    )
    data: List[AuthomizeExternalRestApiAppRoutesSchemaInventoryIdentitySchema] = Field(
        ..., description='List of Actual Data', title='Data'
    )


class PaginatedResponseSchemaIncidentSchema(BaseModel):
    class Config:
        extra = Extra.forbid

    pagination: Optional[PaginationResponseSchema] = Field(
        None, description='Pagination Metadata', title='Pagination'
    )
    data: List[IncidentSchema] = Field(..., description='List of Actual Data', title='Data')


class AllSchemasResponseSchema(BaseModel):
    v1_bundle_schema: Optional[ItemsBundleSchema] = None
    v2_bundle_schema: Optional[RequestsBundleSchema] = None
    v2_data_only_schema: Optional[IngestionDataBundleSchema] = None
