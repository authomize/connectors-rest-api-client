# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2022-08-02T20:35:01+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, constr


class AccessTypes(Enum):
    Unknown = 'Unknown'
    All = 'All'
    Owner = 'Owner'
    Read = 'Read'
    ReadMetadata = 'ReadMetadata'
    Write = 'Write'
    Create = 'Create'
    Delete = 'Delete'
    Execute = 'Execute'
    Enable = 'Enable'
    Assign = 'Assign'
    Restore = 'Restore'
    Import = 'Import'
    Export = 'Export'
    Get = 'Get'
    Set = 'Set'
    Update = 'Update'
    Cancel = 'Cancel'
    Use = 'Use'
    AllowUse = 'AllowUse'
    List = 'List'
    Administrative = 'Administrative'
    Delegate = 'Delegate'
    Join = 'Join'
    Invite = 'Invite'
    Leave = 'Leave'
    Share = 'Share'


class AssetType(Enum):
    Application = 'Application'
    Database = 'Database'
    Drive = 'Drive'
    File = 'File'
    Folder = 'Folder'
    GitRepository = 'GitRepository'
    Integration = 'Integration'
    Project = 'Project'
    Site = 'Site'
    Table = 'Table'
    Ticket = 'Ticket'
    VirtualMachine = 'VirtualMachine'
    Other = 'Other'


class AssetTypes(Enum):
    Resource = 'Resource'
    File = 'File'
    Folder = 'Folder'
    Drive = 'Drive'
    Site = 'Site'
    Application = 'Application'
    Integration = 'Integration'
    Package = 'Package'
    Project = 'Project'
    Cluster = 'Cluster'
    Dataset = 'Dataset'
    Subscription = 'Subscription'
    Table = 'Table'
    TableRecord = 'TableRecord'
    Disk = 'Disk'
    Image = 'Image'
    Instance = 'Instance'
    Snapshot = 'Snapshot'
    Service = 'Service'
    Topic = 'Topic'
    Bucket = 'Bucket'
    BillingAccount = 'BillingAccount'
    Device = 'Device'
    Calendar = 'Calendar'
    Policy = 'Policy'
    GitRepository = 'GitRepository'
    Network = 'Network'
    Vpc = 'Vpc'
    NetworkInterface = 'NetworkInterface'
    VirtualMachine = 'VirtualMachine'
    NetworkSecurityGroup = 'NetworkSecurityGroup'
    Ticket = 'Ticket'
    NetworkSubnet = 'NetworkSubnet'
    NetworkAcl = 'NetworkAcl'
    RouteTable = 'RouteTable'
    NetworkAddress = 'NetworkAddress'
    Secret = 'Secret'
    Storage = 'Storage'
    Workspace = 'Workspace'
    SharedLink = 'SharedLink'
    Collection = 'Collection'
    Database = 'Database'
    ServerlessFunction = 'ServerlessFunction'
    ServerlessApplication = 'ServerlessApplication'
    Gateway = 'Gateway'
    ImageRepository = 'ImageRepository'
    Resource_BusinessAccount = 'Resource_BusinessAccount'
    LoadBalancer = 'LoadBalancer'
    Listener = 'Listener'


class AssetsInheritance(BaseModel):
    fromId: str = Field(..., title='Fromid')
    toId: str = Field(..., title='Toid')


class AvailableConnectorId(Enum):
    restApiImport = 'restApiImport'


class ConnectorStatus(Enum):
    initializing = 'initializing'
    validating = 'validating'
    failure = 'failure'
    enabled = 'enabled'
    installable = 'installable'
    archived = 'archived'
    disabled = 'disabled'
    deleted = 'deleted'


class ExportResponse(BaseModel):
    exportId: str = Field(..., title='Exportid')
    exportUrl: str = Field(..., title='Exporturl')


class GroupingType(Enum):
    Group = 'Group'
    VirtualGroup = 'VirtualGroup'


class IdentitiesInheritance(BaseModel):
    fromId: str = Field(..., title='Fromid')
    toId: str = Field(..., title='Toid')


class IdentityTypes(Enum):
    Identity = 'Identity'
    User = 'User'
    Group = 'Group'
    EntitlementProxy = 'EntitlementProxy'
    AccessKey = 'AccessKey'
    ServiceAccount = 'ServiceAccount'
    Alias = 'Alias'
    Domain = 'Domain'
    Organization = 'Organization'
    TaskPerformer = 'TaskPerformer'
    BusinessAccount = 'BusinessAccount'


class IsAliveResponse(BaseModel):
    isAlive: bool = Field(..., description='**isAlive**', title='Isalive')


class MeResponse(BaseModel):
    version: str = Field(..., description='**version**', title='Version')
    id: str = Field(..., description='**id**', title='Id')
    tenant: str = Field(..., description='**tenant**', title='Tenant')


class NewAccountsAssociationRequestSchema(BaseModel):
    sourceId: str = Field(..., description='Source account ID ##Mandatory##\n', title='Sourceid')
    targetId: str = Field(..., description='Target acount ID ##Mandatory##\n', title='Targetid')


class NewAssetsInheritanceRequestSchema(BaseModel):
    sourceId: str = Field(
        ..., description='ID of the source asset. ##Mandatory##\n', title='Sourceid'
    )
    targetId: str = Field(
        ...,
        description='The ID of the iherited asset (or assets). ##Mandatory##\n',
        title='Targetid',
    )


class NewAssetsRequestSchema(BaseModel):
    id: str = Field(..., description='ID of asset. ##Mandatory##\n', title='Id')
    name: str = Field(
        ..., description='The name of the asset. The default is the Asset ID.\n', title='Name'
    )
    type: Optional[AssetType] = Field(
        'Other',
        description='Tthe asset types that are supported by Authomize ##Mandatory##\nAllowed values: \n   •\tApplication (federation) \n   •\tDatabase\n   •\tDrive\n   •\tFile\n   •\tFolder\n   •\tGit Repository\n   •\tIntegration\n   •\tProject\n   •\tSite\n   •\tTable\n   •\tTicket\n   •\tVirtual Machine\nIf the asset type does not exist use “other”.\n',
    )
    originType: Optional[str] = Field(
        'Group',
        description='The asset types that are supported by Authomize ##Mandatory##\nAllowed values: \n   •\tApplication (federation) \n   •\tDatabase\n   •\tDrive\n   •\tFile\n   •\tFolder\n   •\tGit Repository\n   •\tIntegration\n   •\tProject\n   •\tSite\n   •\tTable\n   •\tTicket\n   •\tVirtual Machine\nIf the asset type does not exist use “other”.',
        title='Origintype',
    )
    createdAt: Optional[datetime] = Field(
        None,
        description='The date (in ISO format) that the asset was created.\nThe default is null.\n',
        title='Createdat',
    )
    description: Optional[str] = Field(
        None,
        description='A description of the asset (up to 512 characters).\n',
        title='Description',
    )
    href: Optional[str] = Field(
        None, description='A link to the asset in the source system.\n', title='Href'
    )
    tags: Optional[List[str]] = Field(
        None, description='Tags associated with the asset.\n', title='Tags'
    )


class NewGroupingRequestSchema(BaseModel):
    id: str = Field(..., description='User IDs must be unique **Mandatory**\n', title='Id')
    name: str = Field(
        ...,
        description='The name of the grouping. The default is the ID field. **Optional**\n',
        title='Name',
    )
    originType: Optional[str] = Field(
        'Group',
        description='The name of the type of grouping in the source system. The default is group. Example: Group/Alias/AWS Role\n',
        title='Origintype',
    )
    type: Optional[GroupingType] = Field(
        'Group',
        description='Allowed values are "Group" and "Virtual Group". The default is group.\nVirtual groups are mapped to the Authomize access explorer graph and are not present in other places in the user interface nor are they counted as a group.\n',
    )
    anyoneCanJoinOrLeave: Optional[bool] = Field(
        False,
        description='When set to "TRUE" Users can give themselves membership in this grouping without the grouping\'s managers\' or owners\' permission. \nExamples include public groups (M365), Google Groups with specific flags, ...\nAllowed values: True, False\nDefault = False\nValid only when grouping type = group\n',
        title='Anyonecanjoinorleave',
    )
    role: Optional[str] = Field(
        None,
        description='The name of the role name the source application. The default is null. \nIf the role name is specified, the groupings are a representation of a global role on the entire application.\n',
        title='Role',
    )
    tags: Optional[List[str]] = Field(
        None, description='Tags on the access grouping.\n', title='Tags'
    )


class NewGroupingResponseSchema(BaseModel):
    acceptedTimestamp: datetime = Field(
        ..., description='**The accepted time of the request**', title='Acceptedtimestamp'
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )


class NewGroupsAssociationRequestSchema(BaseModel):
    sourceId: str = Field(..., description='Grouping source ID ##Mandatory##\n', title='Sourceid')
    targetId: str = Field(
        ...,
        description='Grouping Target Id (the grouping to associate with) ##Mandatory##\n',
        title='Targetid',
    )


class NewRestApiConnectorSchema(BaseModel):
    config: Optional[Dict[str, Any]] = Field(None, title='Config')
    serviceId: constr(min_length=1) = Field(..., title='Serviceid')


class NewUserResponseSchema(BaseModel):
    acceptedTimestamp: datetime = Field(
        ..., description='**The accepted time of the request**', title='Acceptedtimestamp'
    )
    requestId: str = Field(..., description='**Request id**', title='Requestid')
    numberOfAcceptedEntities: int = Field(
        ...,
        description='**The number of entities that pass validation and uploaded**',
        title='Numberofacceptedentities',
    )


class Pagination(BaseModel):
    limit: Optional[int] = Field(-1, title='Limit')
    skip: Optional[int] = Field(0, title='Skip')
    total: Optional[int] = Field(-1, title='Total')
    hasMore: Optional[bool] = Field(None, title='Hasmore')


class PrivilegeType(Enum):
    Administrative = 'Administrative'
    Unknown = 'Unknown'
    Read = 'Read'
    ReadMetadata = 'ReadMetadata'
    Write = 'Write'
    Create = 'Create'
    Delete = 'Delete'
    Execute = 'Execute'
    Enable = 'Enable'
    Assign = 'Assign'
    Restore = 'Restore'
    Import = 'Import'
    Export = 'Export'
    Update = 'Update'
    Cancel = 'Cancel'
    Use = 'Use'
    Delegate = 'Delegate'
    Join = 'Join'
    Invite = 'Invite'
    Share = 'Share'


class RestApiConnectorSchema(BaseModel):
    config: Optional[Dict[str, Any]] = Field(None, title='Config')
    serviceId: Optional[str] = Field('', title='Serviceid')
    id: str = Field(..., title='Id')
    createdAt: Optional[datetime] = Field(None, title='Createdat')
    lastSyncedAt: Optional[str] = Field(None, title='Lastsyncedat')
    lastError: Optional[str] = Field(None, title='Lasterror')
    modifiedAt: Optional[str] = Field(None, title='Modifiedat')
    status: Optional[ConnectorStatus] = 'disabled'
    serviceType: str = Field(..., title='Servicetype')
    availableConnectorId: Optional[AvailableConnectorId] = 'restApiImport'
    actorType: Optional[str] = Field(None, title='Actortype')
    actorId: Optional[str] = Field(None, title='Actorid')


class ServiceDescription(BaseModel):
    name: str = Field(..., title='Name')
    icon: Optional[str] = Field(None, title='Icon')


class SubmitResponse(BaseModel):
    acceptedTimestamp: datetime = Field(
        ..., description='**The accepted time of the request**', title='Acceptedtimestamp'
    )


class TransactionStateType(Enum):
    Applying = 'Applying'
    Complete = 'Complete'
    Failed = 'Failed'
    Ingest = 'Ingest'
    IngestChunk = 'IngestChunk'
    PostProcess = 'PostProcess'
    Queue = 'Queue'


class UserStatus(Enum):
    Staged = 'Staged'
    Enabled = 'Enabled'
    Disabled = 'Disabled'
    Suspended = 'Suspended'
    Deleted = 'Deleted'
    Unknown = 'Unknown'


class ValidationError(BaseModel):
    loc: List[str] = Field(..., title='Location')
    msg: str = Field(..., title='Message')
    type: str = Field(..., title='Error Type')


class AccessDescription(BaseModel):
    fromIdentityId: str = Field(..., title='Fromidentityid')
    toAssetId: str = Field(..., title='Toassetid')
    accessType: AccessTypes
    accessName: Optional[str] = Field(None, title='Accessname')


class AssetDescription(BaseModel):
    id: str = Field(..., title='Id')
    name: str = Field(..., title='Name')
    type: AssetTypes
    description: Optional[str] = Field(None, title='Description')
    logoUrl: Optional[str] = Field(None, title='Logourl')
    href: Optional[str] = Field(None, title='Href')
    createdAt: Optional[datetime] = Field(None, title='Createdat')
    isAuxiliary: Optional[bool] = Field(None, title='Isauxiliary')
    service: Optional[str] = Field(None, title='Service')
    isFederated: Optional[bool] = Field(None, title='Isfederated')


class BundleTransactionSchema(BaseModel):
    connectorId: str = Field(..., title='Connectorid')
    transactionCreatedAt: Optional[datetime] = Field(None, title='Transactioncreatedat')
    warnings: Optional[List[str]] = Field(None, title='Warnings')
    validations: Optional[Dict[str, Any]] = Field(None, title='Validations')
    id: str = Field(..., title='Id')
    state: TransactionStateType


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(None, title='Detail')


class IdentityDescription(BaseModel):
    id: str = Field(..., title='Id')
    name: Optional[str] = Field(None, title='Name')
    type: IdentityTypes
    userType: Optional[str] = Field(None, title='Usertype')
    email: Optional[str] = Field(None, title='Email')
    manager: Optional[str] = Field(None, title='Manager')
    title: Optional[str] = Field(None, title='Title')
    department: Optional[str] = Field(None, title='Department')
    description: Optional[str] = Field(None, title='Description')
    href: Optional[str] = Field(None, title='Href')
    createdAt: Optional[datetime] = Field(None, title='Createdat')
    terminationDate: Optional[datetime] = Field(None, title='Terminationdate')
    isExternal: Optional[bool] = Field(None, title='Isexternal')
    isAuxiliary: Optional[bool] = Field(None, title='Isauxiliary')
    hasTwoFactorAuthenticationEnabled: Optional[bool] = Field(
        None, title='Hastwofactorauthenticationenabled'
    )
    firstName: Optional[str] = Field(None, title='Firstname')
    lastName: Optional[str] = Field(None, title='Lastname')
    userName: Optional[str] = Field(None, title='Username')
    status: Optional[UserStatus] = None
    service: Optional[str] = Field(None, title='Service')
    lastLoginDate: Optional[datetime] = Field(None, title='Lastlogindate')
    anyoneCanJoinOrLeave: Optional[bool] = Field(None, title='Anyonecanjoinorleave')
    tags: Optional[List[str]] = Field(None, title='Tags')


class ItemsBundleSchema(BaseModel):
    services: Optional[List[ServiceDescription]] = Field(None, title='Services')
    identities: List[IdentityDescription] = Field(..., title='Identities')
    assets: List[AssetDescription] = Field(..., title='Assets')
    inheritanceIdentities: List[IdentitiesInheritance] = Field(..., title='Inheritanceidentities')
    inheritanceAssets: List[AssetsInheritance] = Field(..., title='Inheritanceassets')
    access: List[AccessDescription] = Field(..., title='Access')


class NewPermissionsRequestSchema(BaseModel):
    formId: str = Field(..., description='**fromId**', title='Formid')
    originType: Optional[str] = Field(None, description='**originType**', title='Origintype')
    privilegeType: Optional[PrivilegeType] = Field(
        'Use',
        description='Allowed values: "Administrative", "Unknown", "Read", "Read Metadata", "Write", "Create", "Delete", "Execute", "Enable", "Assign", "Restore", "Import", "Export", "Update", "Cancel", "Use", "Delegate", "Join", "Invite", "Share".  ##Mandatory##\n',
    )
    targetAssets: Optional[List[str]] = Field(
        None,
        description='The ID of the asset. When NULL, the entire application has global permission.\n',
        title='Targetassets',
    )
    anyoneCanJoinOrLeave: Optional[bool] = Field(
        False,
        description='When set to "True" users can make themselves a member in this grouping without the managers or owners of the grouping. \nExamples include public groups (Microsoft 365) and Google Groups with specific flags.\nThe default is "False".\nThis is valid only when the grouping type = group.\n',
        title='Anyonecanjoinorleave',
    )
    role: Optional[str] = Field(
        None,
        description='The name of the role in the source application. \nIf the role name is specified, the permissions represent the role. \nThe default is null.\n',
        title='Role',
    )
    tags: Optional[List[str]] = Field(
        None, description='Tags on access permissions.\n', title='Tags'
    )


class NewUserRequestSchema(BaseModel):
    id: str = Field(..., description='Account ID ##Mandatory##\n', title='Id')
    name: Optional[str] = Field(None, description='Username\n', title='Name')
    email: Optional[str] = Field(None, description="User's email address\n", title='Email')
    firstName: Optional[str] = Field(None, description="User's first name\n", title='Firstname')
    lastName: Optional[str] = Field(None, description="The user's last name.\n", title='Lastname')
    status: Optional[UserStatus] = Field(
        None,
        description='User status may be, "Enabled", "Disabled", "staged", "Suspended", "Deleted"\n',
    )
    description: Optional[str] = Field(
        None, description='Additional description of the user\n', title='Description'
    )
    isExternal: Optional[bool] = Field(
        None,
        description='Account is external to Authomize. Options: "True", "False"\n',
        title='Isexternal',
    )
    hasTwoFactorAuthenticationEnabled: Optional[bool] = Field(
        None,
        description='Has Two Factor Authentication enabled\n',
        title='Hastwofactorauthenticationenabled',
    )
    lastLoginDate: Optional[datetime] = Field(
        None, description='The last login date in ISO 8601 format.\n', title='Lastlogindate'
    )
    tags: Optional[List[str]] = Field(
        None, description='One or more tags on the user account.\n', title='Tags'
    )


class RestApiConnectorListSchema(BaseModel):
    pagination: Pagination
    data: List[RestApiConnectorSchema] = Field(..., title='Data')


class TransactionPaginatedSearchSchema(BaseModel):
    data: List[BundleTransactionSchema] = Field(..., title='Data')
    pagination: Pagination
